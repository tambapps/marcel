<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Marcel Programming Language</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="marcel.html">The Marcel Programming Language</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="getting-started/hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello World</a></li></ol></li><li class="chapter-item expanded "><a href="language-specification/index.html"><strong aria-hidden="true">2.</strong> Language Specification</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language-specification/syntax/index.html"><strong aria-hidden="true">2.1.</strong> Syntax</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language-specification/syntax/comments.html"><strong aria-hidden="true">2.1.1.</strong> Comments</a></li><li class="chapter-item expanded "><a href="language-specification/syntax/keywords.html"><strong aria-hidden="true">2.1.2.</strong> Keywords</a></li><li class="chapter-item expanded "><a href="language-specification/syntax/identifiers.html"><strong aria-hidden="true">2.1.3.</strong> Identifier rules</a></li><li class="chapter-item expanded "><a href="language-specification/syntax/literal-values.html"><strong aria-hidden="true">2.1.4.</strong> Literal Values</a></li></ol></li><li class="chapter-item expanded "><a href="language-specification/variables.html"><strong aria-hidden="true">2.2.</strong> Variables</a></li><li class="chapter-item expanded "><a href="language-specification/types.html"><strong aria-hidden="true">2.3.</strong> Types</a></li><li class="chapter-item expanded "><a href="language-specification/control-flows/index.html"><strong aria-hidden="true">2.4.</strong> Control Flows</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language-specification/control-flows/marcel-truth.html"><strong aria-hidden="true">2.4.1.</strong> Marcel Truth</a></li><li class="chapter-item expanded "><a href="language-specification/control-flows/if-else.html"><strong aria-hidden="true">2.4.2.</strong> If/Else Statements</a></li><li class="chapter-item expanded "><a href="language-specification/control-flows/for-loops.html"><strong aria-hidden="true">2.4.3.</strong> For loops</a></li><li class="chapter-item expanded "><a href="language-specification/control-flows/switch-when.html"><strong aria-hidden="true">2.4.4.</strong> Switch and When</a></li><li class="chapter-item expanded "><a href="language-specification/control-flows/try-catch.html"><strong aria-hidden="true">2.4.5.</strong> Try/Catch/Finally</a></li></ol></li><li class="chapter-item expanded "><a href="language-specification/source-file-structure/index.html"><strong aria-hidden="true">2.5.</strong> Source File Structure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language-specification/source-file-structure/imports.html"><strong aria-hidden="true">2.5.1.</strong> Imports</a></li><li class="chapter-item expanded "><a href="language-specification/source-file-structure/visibility.html"><strong aria-hidden="true">2.5.2.</strong> Visibility and Access</a></li><li class="chapter-item expanded "><a href="language-specification/source-file-structure/functions.html"><strong aria-hidden="true">2.5.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="language-specification/source-file-structure/classes.html"><strong aria-hidden="true">2.5.4.</strong> Classes</a></li><li class="chapter-item expanded "><a href="language-specification/source-file-structure/script.html"><strong aria-hidden="true">2.5.5.</strong> Script</a></li></ol></li><li class="chapter-item expanded "><a href="language-specification/operators/index.html"><strong aria-hidden="true">2.6.</strong> Operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language-specification/operators/plus.html"><strong aria-hidden="true">2.6.1.</strong> Plus (+)</a></li><li class="chapter-item expanded "><a href="language-specification/operators/minus.html"><strong aria-hidden="true">2.6.2.</strong> Minus (-)</a></li><li class="chapter-item expanded "><a href="language-specification/operators/comparison.html"><strong aria-hidden="true">2.6.3.</strong> Comparison Operators</a></li><li class="chapter-item expanded "><a href="language-specification/operators/indexed-access.html"><strong aria-hidden="true">2.6.4.</strong> Indexed Access (expr[index])</a></li><li class="chapter-item expanded "><a href="language-specification/operators/safe-navigation.html"><strong aria-hidden="true">2.6.5.</strong> Safe Navigation (?.)</a></li><li class="chapter-item expanded "><a href="language-specification/operators/operator-overloading.html"><strong aria-hidden="true">2.6.6.</strong> Define your own operators</a></li></ol></li><li class="chapter-item expanded "><a href="language-specification/lambdas.html"><strong aria-hidden="true">2.7.</strong> Lambdas</a></li><li class="chapter-item expanded "><a href="language-specification/extension-classes.html"><strong aria-hidden="true">2.8.</strong> Extension Classes</a></li><li class="chapter-item expanded "><a href="language-specification/dynamic-objects.html"><strong aria-hidden="true">2.9.</strong> Dynamic Objects</a></li></ol></li><li class="chapter-item expanded "><a href="tools/index.html"><strong aria-hidden="true">3.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/marcl.html"><strong aria-hidden="true">3.1.</strong> MarCL - Marcel's Command Line tool</a></li><li class="chapter-item expanded "><a href="tools/marshell.html"><strong aria-hidden="true">3.2.</strong> Marshell - Marcel Shell</a></li><li class="chapter-item expanded "><a href="tools/marshell-for-android.html"><strong aria-hidden="true">3.3.</strong> Marshell for Android</a></li><li class="chapter-item expanded "><a href="tools/dumbbell.html"><strong aria-hidden="true">3.4.</strong> Dumbbell - Marcel's Dependency Manager</a></li><li class="chapter-item expanded "><a href="tools/intelij-plugin.html"><strong aria-hidden="true">3.5.</strong> IntelIJ Plugin for Marcel</a></li></ol></li><li class="chapter-item expanded "><a href="tutorials/index.html"><strong aria-hidden="true">4.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/pattern-matching.html"><strong aria-hidden="true">4.1.</strong> Pattern Matching</a></li></ol></li><li class="chapter-item expanded "><a href="marcel-in-action.html"><strong aria-hidden="true">5.</strong> Marcel In Action</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Marcel Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="marcel-a-simple-and-efficient-programming-language-for-any-jvm"><a class="header" href="#marcel-a-simple-and-efficient-programming-language-for-any-jvm">Marcel, a simple and efficient programming language for any JVM</a></h1>
<p>Marcel is a programming language built with the following goals in mind:</p>
<ul>
<li>Being simple, not too verbose, allowing to write programs quickly</li>
<li>Runnable on Android devices (this language is <strong>guaranteed</strong> to be compilable and executable on any Android devices)</li>
</ul>
<p>Its features are inspired from many languages such as Groovy, Kotlin, Perl and Dart. You can consult the source code of
this language <a href="https://github.com/tambapps/marcel">on GitHub</a></p>
<br/>
Marcel compiles to Java bytecode (.class files). You can execute marcel script/projects on any JVMs, as long as the Marcel stdlib is included
in your classpath.
<p>As stated above, marcel is guaranteed to be compilable and executable on any Android devices. An android app will come soon(-ish)
for that.</p>
<br/>
<p>Some integrations with Android APIs should come at some point (e.g. send SMS from a Marcel script, run a Marcel script 
on the background with Android's <a href="https://developer.android.com/topic/libraries/architecture/workmanager">WorkManager</a> 
and get a notification once the work is finished)</p>
<br/>
<p>Note that this language is at an early development stage (it started on January 2023) and is therefore not stable yet. I will do my
best not to bring radical changes, but I cannot guaranty that yet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>In this section we'll discuss:</p>
<ul>
<li>Installing Marcel</li>
<li>Writing and running a Marcel program that prints <code>Hello World</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Marcel comes with</p>
<ul>
<li><a href="getting-started/../tools/marcl.html">marcl</a></li>
<li><a href="getting-started/../tools/marshell.html">marshell</a></li>
<li><a href="getting-started/../tools/dumbbell.html">dumbbell</a></li>
</ul>
<p>For now, the only way to install Marcel is compiling it from its source code.</p>
<h2 id="install-from-source-code"><a class="header" href="#install-from-source-code">Install from source code</a></h2>
<p>There is a <a href="https://github.com/tambapps/marcel/blob/main/install.sh">script in marcel repository</a> for that.</p>
<p>Note that this script <strong>only works on Linux and Mac</strong>.</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<p>You'll need Maven for the installation.</p>
<h3 id="run-script"><a class="header" href="#run-script">Run script</a></h3>
<p>Clone the repository</p>
<pre><code class="language-shell">git clone https://github.com/tambapps/marcel.git
cd marcel
</code></pre>
<p>And then run the script</p>
<pre><code class="language-shell">./install.sh
</code></pre>
<p>The script basically runs a lot of <code>mvn clean install</code> and then copy/create some files in <code>$HOME/.marcel/</code>.</p>
<p>Lastly, you can add the following lines into your <code>$HOME/.bashrc</code> (or <code>$HOME/.zshrc</code> or whatever) to easily use marcel tools</p>
<pre><code class="language-shell">MARCEL_HOME=&quot;$HOME/.marcel&quot;
PATH=&quot;$PATH:$MARCEL_HOME/bin&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>Let's dive in some code now. Marcel can be used as a scripting language, so you don't need to declare a <code>main()</code> function
if you just want to run some code.</p>
<pre><code class="language-kotlin">// HelloWorld.mcl
println(&quot;Hello World!&quot;)
</code></pre>
<p>That's it! One line is all it takes to write the famous Hello World program.</p>
<p>To execute it, use <a href="getting-started/../tools/marcl.html">marcl</a>.</p>
<pre><code class="language-shell">marcl HelloWorld.mcl
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-specification"><a class="header" href="#language-specification">Language Specification</a></h1>
<p>In this section, you'll learn all the little secrets of MarcelLang.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<p>This chapter covers the syntax of the Marcel programming language.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>You can comment your code in Marcel the same way you would in Java.</p>
<p>Define comments like you would in Java. <code>// ...</code> for a single line comment, and <code>/* ... */</code> for a multi-line comment</p>
<pre><code class="language-kotlin">// this function does stuff
doStuff()

/* this function
  does some
  other stuff
 */
doOtherStuff()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keywords"><a class="header" href="#keywords">Keywords</a></h1>
<p>Marcel has the following keywords, which you cannot use as variable/function names</p>
<ul>
<li>int</li>
<li>long</li>
<li>short</li>
<li>float</li>
<li>double</li>
<li>bool</li>
<li>byte</li>
<li>void</li>
<li>char</li>
<li>fun</li>
<li>return</li>
<li>true</li>
<li>false</li>
<li>new</li>
<li>import</li>
<li>as</li>
<li>inline</li>
<li>static</li>
<li>for</li>
<li>in</li>
<li>if</li>
<li>else</li>
<li>null</li>
<li>break</li>
<li>def</li>
<li>class</li>
<li>extension</li>
<li>package</li>
<li>extends</li>
<li>implements</li>
<li>final</li>
<li>switch</li>
<li>when</li>
<li>this</li>
<li>super</li>
<li>dumbbell</li>
<li>try</li>
<li>catch</li>
<li>finally</li>
<li>instanceof</li>
<li>throw</li>
<li>throws</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h1>
<p>An identifier is a name that you can use to define a class, field, a function or variable.</p>
<p>An identifier must follows all the below rules</p>
<ul>
<li>it must start with a letter ('a' to 'z' , and 'A' to 'Z'), or an underscore</li>
<li>the following characters can be a letter, an underscore or a number</li>
</ul>
<h2 id="class-identifiers"><a class="header" href="#class-identifiers">Class identifiers</a></h2>
<p>To reference a class, you need tp add the <code>.class</code> suffix, like in Java.
But note that you can only reference simple name of classes, this means that you need to import it first.</p>
<pre><code class="language-groovy">import java.util.concurrent.Callable
println(Callable.class)

println(Object.class)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>There are different ways to create strings in Marcel</p>
<h3 id="strings-1"><a class="header" href="#strings-1">Strings</a></h3>
<p>You can use the single quote character (<code>'</code>) to create strings</p>
<pre><code class="language-kotlin">'Hello world!'
</code></pre>
<h3 id="interpolated-strings"><a class="header" href="#interpolated-strings">Interpolated strings</a></h3>
<p>You can use the double quote character (<code>&quot;</code>) to create strings resolving variables</p>
<pre><code class="language-kotlin">&quot;$firstName $lastName is $age years old&quot;
</code></pre>
<p>If you need to access a property, use the brackets</p>
<pre><code class="language-kotlin">&quot;${person.firstName} ${person.lastName} is ${person.age} years old&quot;
</code></pre>
<h3 id="pattern-strings"><a class="header" href="#pattern-strings">Pattern strings</a></h3>
<p>You can instantiate <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">Patterns</a> using backslash strings. 
These strings are reserved for pattern only.</p>
<p>The backslash is <strong>not</strong> considered as an escape, except for the backlash character
(which would be escaped as <code>\/</code>).</p>
<pre><code class="language-javascript">/some \w+/
</code></pre>
<p>Note that such strings <strong>doesn't</strong> resolve variables. If you want to construct a Pattern while resolving Strings, you could
just call the <code>Pattern.compile(String)</code> method with an interpolated string.</p>
<br/>
It is good practise to end such regexes with a semi-colon (`;`) character, to make it clear to the compiler that what follows
is not a regex flag (we'll talk about that just after) but a 'real' identifier.
<p>E.g.</p>
<pre><code class="language-javascript">Pattern pattern = /myPattern/; // without the semi-colon, Marcel would think that 'println' characters are regex flags
println(pattern)
</code></pre>
<h4 id="pattern-flags"><a class="header" href="#pattern-flags">Pattern flags</a></h4>
<p>You can also specify flags by adding a suffix at the end of your regex String.</p>
<pre><code class="language-javascript">Pattern pattern = /myPattern/iu; // you can specify many flags at once
println(pattern)
</code></pre>
<p>Here is the list of flags (you can see the doc of each flag in the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#UNIX_LINES">Javadoc of the Pattern's class</a>).</p>
<div class="table-wrapper"><table><thead><tr><th>character</th><th>Java PatternFlag</th></tr></thead><tbody>
<tr><td>d</td><td>UNIX_LINES</td></tr>
<tr><td>i</td><td>CASE_INSENSITIVE</td></tr>
<tr><td>x</td><td>COMMENTS</td></tr>
<tr><td>m</td><td>MULTILINE</td></tr>
<tr><td>l</td><td>LITERAL</td></tr>
<tr><td>s</td><td>DOTALL</td></tr>
<tr><td>u</td><td>UNICODE_CASE</td></tr>
<tr><td>c</td><td>CANON_EQ</td></tr>
<tr><td>U</td><td>UNICODE_CHARACTER_CLASS</td></tr>
</tbody></table>
</div>
<h3 id="character"><a class="header" href="#character">Character</a></h3>
<p>Use the backtick (<code>`</code>) to create primitive characters.
Only one character must be specified between the two backticks</p>
<pre><code class="language-java">char c = `A`
</code></pre>
<h3 id="escaped-characters"><a class="header" href="#escaped-characters">Escaped characters</a></h3>
<p>Use backslash to escape 'special' characters within strings/characters. Here is the list of escaped characters</p>
<div class="table-wrapper"><table><thead><tr><th>escaped character</th><th>represented value</th></tr></thead><tbody>
<tr><td>\b</td><td>backspace</td></tr>
<tr><td>\n</td><td>newline</td></tr>
<tr><td>\r</td><td>carriage return</td></tr>
<tr><td>\t</td><td>tabulation</td></tr>
<tr><td>\\</td><td>backslash</td></tr>
<tr><td>\'</td><td>single quotes (useful in simple strings)</td></tr>
<tr><td>\&quot;</td><td>double quotes (useful in interpolated strings)</td></tr>
<tr><td>\`</td><td>backtick (useful in character strings)</td></tr>
</tbody></table>
</div>
<h2 id="literal-numbers"><a class="header" href="#literal-numbers">Literal Numbers</a></h2>
<p>Marcel supports almost all Java primitives. The number primitive literals are the same as in Java</p>
<pre><code class="language-java">// primitive types
byte  b = 1
short s = 2
int   i = 3
long  l = 4l
float f = 5f
double d = 6d
</code></pre>
<h3 id="binary-representation"><a class="header" href="#binary-representation">Binary representation</a></h3>
<p>You can also create numbers using their binary representation with the <code>0b</code> prefix</p>
<pre><code class="language-java">int i = 0b10
long l = 0b11l
</code></pre>
<h3 id="hexadecimal-representation"><a class="header" href="#hexadecimal-representation">Hexadecimal representation</a></h3>
<p>You can also create numbers using their hexadecimal representation with the <code>0x</code> prefix</p>
<pre><code class="language-java">int i = 0x5
long l = 0x5l
</code></pre>
<h2 id="literal-booleans"><a class="header" href="#literal-booleans">Literal Booleans</a></h2>
<p>You can create booleans using the <code>true</code> or <code>false</code> keyword.</p>
<pre><code class="language-java">bool b = true
</code></pre>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>Create arrays with the square brackets</p>
<pre><code class="language-groovy">int[] ints = [1, 2, 3, 4]
</code></pre>
<p>Note that you can also use this syntax to <a href="language-specification/syntax/../types.html#collections-of-primitives">create collections</a>.</p>
<h2 id="maps"><a class="header" href="#maps">Maps</a></h2>
<p>Square brackets can also be used to define maps</p>
<pre><code class="language-groovy">Map map = [1.3: &quot;1&quot;, 1.4: &quot;2&quot;, &quot;myStringKey&quot;: &quot;myStringValue&quot;, myLitteralKey: myRefValue, (myRefKey): myRefValue]
</code></pre>
<p>Note that <code>myLitteralKey</code> is actually a String key, it doesn't refers to a variable (like in Groovy). If you want to reference
a variable as a key, put it between parenthesis, like it is done for <code>(myRefKey)</code>.</p>
<h2 id="ranges"><a class="header" href="#ranges">Ranges</a></h2>
<p>You can create int (and soon long) ranges</p>
<pre><code class="language-groovy">0..10 // 0 (inclusive) to 10 (inclusive)
0&lt;..10 // 0 (exclusive) to 10 (inclusive)
0..&lt;10 // 0 (inclusive) to 10 (exclusive)
0&lt;..&lt;10 // 0 (exclusive) to 10 (exclusive)
</code></pre>
<p>Ranges also work in reverse order</p>
<pre><code class="language-groovy">10..0 // 10 (inclusive) to 0 (inclusive)
10&gt;..0 // 10 (exclusive) to 0 (inclusive)
10..&gt;0 // 10 (inclusive) to 0 (exclusive)
10&gt;..&gt;0 // 10 (exclusive) to 0 (exclusive)
</code></pre>
<p>Ranges work with all kinds of int/long expressions</p>
<pre><code class="language-groovy">int start = computeStart()
int end = computeEnd()

for (i in start..end) println(i)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<h2 id="declare-variables"><a class="header" href="#declare-variables">Declare variables</a></h2>
<p>Marcel variable declarations are the same as Java's</p>
<pre><code class="language-groovy">int a = 2
Object o = new Object()

list&lt;int&gt; l = [1, 2] // collection of primivites
</code></pre>
<h3 id="multiple-declarations"><a class="header" href="#multiple-declarations">Multiple declarations</a></h3>
<p>Marcel supports multiple assignments in one statement</p>
<pre><code class="language-groovy">def (int a, String b, Object c) = [1, &quot;2&quot;, new Object()]

def (int d, String e, Object f) = functionReturningAnArrayOrList()
</code></pre>
<p>Note that if the array/list is shorter than the number of variable declared, this will lead to a runtime error</p>
<br/>
Sometimes you might want to ignore a specific item of a list,
You can use the `_` identifier to let the compiler know that.
<p>E.g.</p>
<pre><code class="language-groovy">def (_, String world) = (&quot;hello world&quot; =~ /hello (world)/).groups()
</code></pre>
<h2 id="variable-assignments"><a class="header" href="#variable-assignments">Variable assignments</a></h2>
<p>Just use <code>=</code> to assign values to defined variables</p>
<pre><code class="language-java">int a = 2

a = 3
</code></pre>
<h3 id="automatic-casting"><a class="header" href="#automatic-casting">Automatic casting</a></h3>
<p>Variable assignments are automatically casted when needed.</p>
<pre><code class="language-groovy">Optional o = Optional.of(123)
Integer myInteger = o.get() // returns Object cast into an Integer 
int myInt = o.get() // returns Object cast into an Integer then into an int
</code></pre>
<p>This can be useful as Marcel <a href="language-specification/./types.html#generic-types">doesn't support generic types</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<h2 id="primitives"><a class="header" href="#primitives">Primitives</a></h2>
<p>Marcel supports the following Java primitives</p>
<ul>
<li>void</li>
<li>boolean</li>
<li>byte</li>
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
</ul>
<p>To see how to create such types, go through the <a href="language-specification/./syntax/literal-values.html">Literal Values section</a></p>
<h2 id="classes"><a class="header" href="#classes">Classes</a></h2>
<p>Marcel is a JVM language, therefore you can use any classes defined in the JDK</p>
<h2 id="collections-of-primitives"><a class="header" href="#collections-of-primitives">Collections of Primitives</a></h2>
<p>Marcel allows to use collections with primitive elements. Such collections will not box all your primitives into their 
related Object class (e.g. store an int into an Integer). The elements will be stored in an array of primitives.</p>
<p>Iterating over such collections will only use primitives, no (un)boxing will be done.</p>
<p>Let's learn by example</p>
<h2 id="lists"><a class="header" href="#lists">Lists</a></h2>
<pre><code class="language-groovy">list&lt;int&gt; list = [1, 2, 3, 4]

println(list[1])

list[1] = 1
println(list[1])
</code></pre>
<p>Here, we're declaring a <code>list&lt;int&gt;</code>. This type isn't actually generic, it is actually an IntList (you can see this class in the marcel stdlib), and the
literal array will be converted into a IntArrayList (a int list that store elements in an int array).</p>
<p>Here is the list of all list of primitives supported</p>
<ul>
<li>list&lt;int&gt; -&gt; IntList</li>
<li>list&lt;long&gt; -&gt; LongList</li>
<li>list&lt;char&gt; -&gt; CharacterList</li>
<li>list&lt;float&gt; -&gt; FloatList</li>
<li>list&lt;double&gt; -&gt; DoubleList</li>
</ul>
<h2 id="sets"><a class="header" href="#sets">Sets</a></h2>
<p>You can do the same with sets</p>
<pre><code class="language-groovy">set&lt;int&gt; mySet = [1, 2, 3, 3] // will actually contain just 1, 2 and 3
</code></pre>
<p>Here is the list of all set of primitives supported</p>
<ul>
<li>set&lt;int&gt; -&gt; IntSet</li>
<li>set&lt;long&gt; -&gt; LongSet</li>
<li>set&lt;char&gt; -&gt; CharacterSet</li>
</ul>
<h2 id="generic-types"><a class="header" href="#generic-types">Generic Types</a></h2>
<p>Marcel <strong>doesn't</strong> support generic types except for primitive collections (which technically aren't really generic). You can use generic classes but cannot specify generic types when using them.
it's a conscious choice made to get rid of some complexity while developing the compiler and also because Java always casts at runtime anyway.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flows"><a class="header" href="#control-flows">Control flows</a></h1>
<p>In this chapter you'll explore all control flows thar Marcels offers, in particular how to perform</p>
<ul>
<li>if/else statements</li>
<li>for loops</li>
<li>while loops</li>
<li>switch</li>
<li>try/catch/finally</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="marcel-truth"><a class="header" href="#marcel-truth">Marcel truth</a></h1>
<p>A truthy value is a value that is considered true for an if, or a while. </p>
<p>A falsey value is a value that is considered false in those places.</p>
<p>The only falsey values are the following:</p>
<ul>
<li><code>false</code> </li>
<li><code>null</code></li>
<li><code>Optional.empty()</code></li>
<li>An empty collection</li>
<li>An empty array</li>
<li>An empty Map</li>
<li>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html">Matcher</a> who's <code>find()</code> method would return false</li>
</ul>
<p>Any other value is truthy.</p>
<p>You can also override the truth for your class if you define a function <code>fun bool isTruthy()</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-expression"><a class="header" href="#if-expression">If expression</a></h1>
<p>If statements are similar as Java's, but you can provide any expression in them. If the provided expression is not a boolean,
the <a href="language-specification/control-flows/marcel-truth.html">Marcel truth</a> will decide if your expression is <code>true</code> or not.</p>
<pre><code class="language-kotlin">if (a == 1) {
  println(&quot;a is 1&quot;)
} else if (a == 2) {
  println(&quot;a is 2&quot;)
} else {
  println(&quot;a is not 1 and not 2&quot;)
}
</code></pre>
<h2 id="if-variable-declaration"><a class="header" href="#if-variable-declaration">if variable declaration</a></h2>
<p>The <a href="language-specification/control-flows/marcel-truth.html">marcel truth</a> allows you to declare variable in an <code>if</code> condition, and execute the code block if the variable is truthy</p>
<pre><code class="language-kotlin">if (Something result = fetchSomething()) {
  println(&quot;Fetched $result&quot;)
}
</code></pre>
<p>You can also unbox Optional values such as in the below example</p>
<pre><code class="language-kotlin">// assuming getOptionalInteger() returns an Optional
if (Integer result = getOptional()) {
  println(result)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-loops"><a class="header" href="#for-loops">For loops</a></h1>
<p>There are different ways to iterate over elements</p>
<h4 id="for-i"><a class="header" href="#for-i">For i</a></h4>
<p>The Java for i is compatible with Marcel</p>
<pre><code class="language-groovy">for (int i = 0; i &lt; 10; i++) {
  println(i)
}
</code></pre>
<h4 id="for-in"><a class="header" href="#for-in">For in</a></h4>
<p>The <code>in</code> keyword allows to iterate over values in an array, any objects implementing Iterable (including all Collections) or Iterator.</p>
<pre><code class="language-groovy">int[] ints = getInts()
for (int i in ints) {
  println(i)
}
</code></pre>
<p>Marcel also have a Ranges, allowing you to iterate with the below syntax</p>
<pre><code class="language-groovy">// inclusive range
for (int i in 0..9) {
  println(i)
}

// exclusive range
for (int i in 0..&lt;10) {
  println(i)
}

// also work in reverse orde
for (int i in 9..0) {
  println(i)
}

// exclusive range
for (int i in 10&gt;..0) {
  println(i)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="switch-and-when"><a class="header" href="#switch-and-when">Switch and When</a></h1>
<p>Marcel defines conditional control flows that can return values. Note that in the below
control flows described, you <strong>can't</strong> re-assign a value to <strong>local variables</strong> created <strong>outside</strong> 
the switch/when scope.</p>
<h2 id="when"><a class="header" href="#when">When</a></h2>
<pre><code class="language-marcel">when {
  string == &quot;foo&quot; -&gt; 2
  string == &quot;bar&quot; -&gt; {
    doSomeStuff()
    3
  }
  otherCondition() -&gt; 4
}
</code></pre>
<p>Each <code>when</code> branch consists of a condition, and a statement. If the given condition is true, the corresponding statement
will be executed.</p>
<p>Whens are very similar to <code>if/elseif/else</code> control flow, but they allow you to <strong>return values</strong>. 
They are useful to assign variables, or returning values in functions.</p>
<p>In the above example, you can notice that a default case is missing.
If no conditions matched, the <code>when</code> will return <code>null</code>.</p>
<p>This means that you must <strong>always</strong> specify an <code>else</code> branch for whens returning primitive types, as they cannot be null.</p>
<pre><code class="language-marcel">int myInt = when {
  string == &quot;foo&quot; -&gt; 2
  string == &quot;bar&quot; -&gt; {
    doSomeStuff()
    3
  }
  string == someString() -&gt; 4
  otherCondition() -&gt; 5
  else -&gt; 5
}
</code></pre>
<h2 id="switch"><a class="header" href="#switch">Switch</a></h2>
<p>Switch are very similar to whens. Every switch can be translated to a when (but the other way around is not true).</p>
<p>In switches, you compare an expression against multiple values. Based on the above <code>when</code> example, we could do the following
<code>switch</code></p>
<pre><code class="language-marcel">switch (string) {
  &quot;foo&quot; -&gt; 2
  &quot;bar&quot; -&gt; {
    doSomeStuff()
    3
  }
  someString() -&gt; 4
}
</code></pre>
<p>You'll notice that we couldn't translate the <code>when</code> condition <code>otherCondition()</code>, this is because it isn't a comparison against
the switched expression.</p>
<p>Each switch branch consists of a value, and a statement. If the provided switch expression matches the branch's expression, 
the corresponding statement will be executed.</p>
<p>Switches also have an else, that is required when returning a primitive</p>
<pre><code class="language-marcel">int myInt = switch (string) {
  &quot;foo&quot; -&gt; 2
  &quot;bar&quot; -&gt; {
    doSomeStuff()
    3
  }
  someString() -&gt; 4
  else -&gt; 5
}
</code></pre>
<h2 id="access-the-switched-expression"><a class="header" href="#access-the-switched-expression">Access the switched expression</a></h2>
<p>The provided expression can be accessed in the switch branches using the implicit variable <code>it</code>.</p>
<pre><code class="language-marcel">int myInt = switch (operator) {
  1 -&gt; it + 1
  else -&gt;  it + 4
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trycatchfinally-not-yet-implemented"><a class="header" href="#trycatchfinally-not-yet-implemented">Try/Catch/Finally (Not Yet Implemented)</a></h1>
<p>Exception handling is very similar as Java's.</p>
<pre><code class="language-groovy">try {
  Object a = null
  println(a.hashCode())
  println(&quot;Successfully tried&quot;)
} catch (IOException|NullPointerException e) {
    println(&quot;Caught exception&quot;)
} finally {
  println(&quot;finally&quot;)
}
</code></pre>
<p>The above code will print</p>
<pre><code class="language-text">Caught exception
Finally
</code></pre>
<h2 id="try-with-resources-not-yet-implemented"><a class="header" href="#try-with-resources-not-yet-implemented">Try with resources (Not Yet Implemented)</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-structure"><a class="header" href="#program-structure">Program structure</a></h1>
<h2 id="package"><a class="header" href="#package">Package</a></h2>
<p>A Marcel source file can have a package. It is optional but if it is specified, it must be the first instruction in the file
(excluding comments)</p>
<pre><code class="language-java">package my.package
</code></pre>
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<p>Then, some <a href="language-specification/source-file-structure/./imports.html">imports</a> can follow. You can consult the default imported class/package <a href="language-specification/source-file-structure/./imports.html#default-imports">here</a></p>
<h2 id="class"><a class="header" href="#class">Class</a></h2>
<p>You can define <a href="language-specification/source-file-structure/./classes.html">classes</a> like in Java. </p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Classes can have <a href="language-specification/source-file-structure/./functions.html">functions</a></p>
<h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<p>Classes can also have <a href="language-specification/source-file-structure/./classes.html#class-fields">fields</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="imports-1"><a class="header" href="#imports-1">Imports</a></h2>
<p>Marcel's imports are very similar to Java's.</p>
<h3 id="class-import"><a class="header" href="#class-import">Class import</a></h3>
<p>Such imports are like Java's</p>
<pre><code class="language-groovy">import java.text.SimpleDateFormat
</code></pre>
<p>But Marcel adds the capability to import a class <code>as</code> a given name. All references to the given name will be replaced by the
actual class imported when compiling</p>
<pre><code class="language-groovy">import java.text.SimpleDateFormat as SDF

SDF sdf = someSdf()
</code></pre>
<h3 id="wildcard-imports"><a class="header" href="#wildcard-imports">Wildcard imports</a></h3>
<p>Again, just like Java</p>
<pre><code class="language-groovy">import java.text.*
</code></pre>
<h3 id="static-imports"><a class="header" href="#static-imports">Static imports</a></h3>
<p>Yup, like in Java</p>
<pre><code class="language-groovy">import static org.junit.jupiter.api.Assertions.assertEquals
</code></pre>
<h3 id="default-imports"><a class="header" href="#default-imports">Default imports</a></h3>
<p>Marcel import by default all the following packages</p>
<ul>
<li>java.lang.*</li>
<li>java.util.*</li>
<li>java.io.*</li>
<li>marcel.lang.*</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visibility-and-access"><a class="header" href="#visibility-and-access">Visibility and Access</a></h1>
<p>In marcel, there are 4 kinds of visibility.</p>
<ul>
<li><code>public</code> -&gt; which refers to Java's public visibility. Your class/method/field may be accessible from any package</li>
<li><code>protected</code> -&gt; which refers to Java's protected visibility. Your class/method/field may only be accessible from other classes in the same package or inheriting your class</li>
<li><code>internal</code> -&gt; which refers to Java's package-private visibility. Your class/method/field may only be accessible from classes in the same package</li>
<li><code>private</code> -&gt; Your method may be accessible only from the class it was defined in</li>
</ul>
<p>The default visibility is <code>public</code> (meaning that when it isn't specified, the class/method/field will be considered as public)</p>
<h2 id="access"><a class="header" href="#access">Access</a></h2>
<p>Class/method/fields access should be specified in the below order.</p>
<ol>
<li>public/protected/internal/private (or nothing, which would default to public visibility)</li>
<li>static (Optional. only if you want your member to be static)</li>
<li>final (Optional. only if you want your member to be final)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-1"><a class="header" href="#functions-1">Functions</a></h1>
<p>Use the <code>fun</code> keyword to define functions</p>
<pre><code class="language-marcel">fun int sum(int a, int b) {
  return a + b
}

protected fun void foo() {
  // do nothing
}
</code></pre>
<p>As shown in the above example, a function define has the following structures</p>
<ol>
<li>starts with the <a href="language-specification/source-file-structure/./visibility.html">visibility</a> which is optional and defaults to <code>public</code>.(you can also define static function with the <code>static</code> keyword)</li>
<li>the <code>fun</code> keyword</li>
<li>the return type</li>
<li>the function's name</li>
<li>the list of your function's parameters. The parameter's type first, and then the parameter's name.</li>
</ol>
<h2 id="function-visibility"><a class="header" href="#function-visibility">Function Visibility</a></h2>
<p>You can specify your function's <a href="language-specification/source-file-structure/./visibility.html">visibility</a> before the <code>fun</code> keyword</p>
<pre><code class="language-kotlin">private fun foo() {
}
</code></pre>
<h2 id="function-calls"><a class="header" href="#function-calls">Function Calls</a></h2>
<p>Function calls are no different than  in any other language</p>
<pre><code class="language-groovy">int result = sum(1, 2)
</code></pre>
<h2 id="cast-results"><a class="header" href="#cast-results">Cast Results</a></h2>
<p>Marcel has a diamond operator for function calls which is different from Java's. It casts the 
result of the function to the specified type.</p>
<pre><code class="language-groovy">Foo otherResult = compute&lt;Foo&gt;()
</code></pre>
<p>This above example isn't really useful as Marcel <a href="language-specification/source-file-structure/../variables.html#automatic-casting">automatically cast variable assignments when needed</a> but this feature can be useful when chaining function calls</p>
<pre><code class="language-groovy">Optional opt = Optional.of(new Foo())
// assuming computeObject() and result return Object in their declaration
Bar result = opt.get&lt;Foo&gt;().computeObject&lt;Bar&gt;()
</code></pre>
<p>But note that this is useless if the function/property already returns the specified type in their declaration.</p>
<h3 id="named-parameters-call"><a class="header" href="#named-parameters-call">Named Parameters Call</a></h3>
<p>You can also specify the name of your parameters. When doing so, the order in which
you specify them doesn't matter.</p>
<p>When you don't specify a parameter, it will default to the type's default value
(0 for primitive types and <code>null</code> for Objects).</p>
<p>Following on our <code>sum()</code> example:</p>
<pre><code class="language-groovy">int result = sum(b: 2, a: 1) // equivalent to sum(1, 2)
int otherResult = sum(a: 1) // equivalent to sum(1, 0)
</code></pre>
<p>named parameters calls can also start (and only start) with positional arguments.</p>
<h4 id="named-parameters-constructor-calls"><a class="header" href="#named-parameters-constructor-calls">Named parameters constructor calls</a></h4>
<p>Such calls also works with constructors. It will find a constructor having the given parameters, but if it can't find it
and your class has a no args constructor (note that there's always one by default if you don't explicitly define one), it will use it
and then initialize the fields having the provided names with their associated argument value.</p>
<p>Here are some examples below.</p>
<pre><code class="language-groovy">class B {
  int i
  int j
  
  constructor(this.i, this.j)

}
class C {
  int a
  int b
}

B b = new B(i: 1, j: 2) // will call new B(i, j) and the fields will be initialized in the constructor
C c = new C(a: 1, b: 2) // will call new C() and then the fields will be initialized outside the constructor

</code></pre>
<pre><code class="language-groovy">int result = sum(2, b: 1) // equivalent to sum(2, 1)


int otherResult = sum(a: 2, 1) // ERROR, positional argument is not at the start 
</code></pre>
<p>Note that you can only used named parameters call for functions of Marcel-compiled classes, because Java doesn't keep method parameter names available at runtime by default.</p>
<h2 id="parameter-default-value"><a class="header" href="#parameter-default-value">Parameter default value</a></h2>
<p>Function parameters can have default values, which are used when you skip the corresponding argument. These can be useful especially
with named parameters function calls. </p>
<pre><code class="language-groovy">fun int sum(int a = 0, int b = 8) {
return a + b
}

sum(a: 2) // 2 + 8
sum(b: 5) // 0 + 8
sum(a: 2, b: 5) // 2 + 5
</code></pre>
<p>You can specify any expression from a static context (this means you can't call/use non static functions/fields from the class your method is defined).</p>
<p>These default parameter values are kept after compilation so you can also benefit them from other Marcel libraries.</p>
<h3 id="fields-constructor-call"><a class="header" href="#fields-constructor-call">Fields Constructor Call</a></h3>
<p>Similar calls also work with constructors. You can specify class's field names with their values to set.
Note that it will only work if your class has a no-arg constructor and that the fields referenced are <code>public</code> and <strong>not</strong> <code>final</code>.</p>
<pre><code class="language-groovy">
Foo foo = new Foo(bar: 1, baz: &quot;baz&quot;)

class Foo {
  int bar
  String baz
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes-1"><a class="header" href="#classes-1">Classes</a></h1>
<p>You can define classes using the <code>class</code> keyword</p>
<pre><code class="language-kotlin">class Foo {

}
</code></pre>
<h2 id="extendingimplementing-classesinterfaces"><a class="header" href="#extendingimplementing-classesinterfaces">Extending/Implementing classes/interfaces</a></h2>
<p>The syntax is like Java's</p>
<pre><code class="language-java">class Foo extends Object implements List&lt;Integer&gt; {

}
</code></pre>
<h2 id="class-visibility"><a class="header" href="#class-visibility">Class visibility</a></h2>
<p>You can specify your class's <a href="language-specification/source-file-structure/./visibility.html">visibility</a> before the <code>class</code> keyword</p>
<pre><code class="language-kotlin">public class Foo {

}
</code></pre>
<h2 id="class-functions"><a class="header" href="#class-functions">Class functions</a></h2>
<p>See the <a href="language-specification/source-file-structure/./functions.html">functions section</a> to see how to define functions</p>
<h2 id="class-fields"><a class="header" href="#class-fields">Class fields</a></h2>
<p>You can define class fields like you would in Java</p>
<pre><code class="language-java">class Foo {
  private int a;
  double b = 3
  Object c;
}
</code></pre>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<p>You can use the keyword <code>constructor</code> to define constructors. The definition is similar to a function</p>
<pre><code class="language-kotlin">class Foo {
  int bar
  String zoo
  
  constructor(int bar, String zoo) {
    this.bar = bar
    this.zoo = zoo
  }
}
</code></pre>
<p>Constructors where you just want to assign values to your fields are common use-cases. Marcel has a syntax
allowing you to write such constructors with a less verbose code.</p>
<pre><code class="language-kotlin">class Foo {
  int bar
  String zoo
  
  constructor(this.bar, this.zoo)
}
</code></pre>
<p>We didn't even specify a function block, but you can specify one if you want. The first statements
of your class will be the field assignments (after the super() call of course).</p>
<h3 id="calling-constructors-not-yet-implemented-for-this"><a class="header" href="#calling-constructors-not-yet-implemented-for-this">Calling constructors (Not Yet Implemented for <code>this</code>)</a></h3>
<p>You can call specific <code>super</code> and <code>this</code> constructors.</p>
<pre><code class="language-groovy">class A {
  int foo
  constructor(this.foo)
}

class B {
  int bar
  constructor(int foo, this.bar): super(foo) {
    println(&quot;Yahoo&quot;)  
  }
  
  constructor(this.bar): this(0, bar)

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="write-scripts"><a class="header" href="#write-scripts">Write Scripts</a></h1>
<p>Scripts don't need a main() function. You can just start writing statements of your script directly, without wrapping them in a method.</p>
<br/>
You can also define functions in your scripts.
<h2 id="local-variables"><a class="header" href="#local-variables">Local Variables</a></h2>
<p>To declare a local variable in a script, simply declare it as you would in a function's body.</p>
<pre><code class="language-groovy">int a = 2
int b
</code></pre>
<h2 id="dynamic-variables"><a class="header" href="#dynamic-variables">Dynamic variables</a></h2>
<p>In scripts, you can use variables that are declared automatically if they don't
exist yet.</p>
<pre><code class="language-groovy">a = 2
println(a)
</code></pre>
<p>In the above script, we didn't declare the variable <code>a</code>. If we were in a regular class this wouldn't compile, but in scripts
it would declare the variable.</p>
<p>Such variables are declared automatically when they are first assigned. This is why the below script wouldn't compile</p>
<pre><code class="language-groovy">println(a) // referencing a variable a, but we didn't assign it before =&gt; semantic error
a = 2
</code></pre>
<p>The type of the variable is determined by the value provided
to assign it. To explicitly specify its type, you can use the <code>as</code> keyword like in the below example</p>
<pre><code class="language-groovy">a = 2 as Integer // declaring a global variable Integer a
println(a)
</code></pre>
<p>Global variables are accessible from anywhere in the script context, as long as it is not static.</p>
<h3 id="type-consistency"><a class="header" href="#type-consistency">Type consistency</a></h3>
<p>Marcel is statically typed, and so are global variables (at least they are considered as so by the compiler).
When you assign a value to a global variable, future assignments must provide a value assignable from the first value used
in the first assignment.</p>
<h3 id="how-global-variables-works"><a class="header" href="#how-global-variables-works">How global variables works</a></h3>
<p>Global variables are variables that are stored in the script's <code>Binding</code>. The means you could also
retrieve them/set them using methods like <code>Script.getVariable(name)</code>/<code>Script.setVariable(name, value)</code></p>
<pre><code class="language-groovy">a = 1

doSomething(a)

a = &quot;2&quot; // Semantic Error: Expected expression of type int but gave String
</code></pre>
<h2 id="fields-1"><a class="header" href="#fields-1">Fields</a></h2>
<p>To declare a class field for your script, you must explicitly provide its visibility, otherwise it will be 
considered as a local variable.</p>
<p>E.g.</p>
<pre><code class="language-groovy">internal int myField1 = 2
protected myfield2
</code></pre>
<p>Note that global variables are a lot like field variables so you don't need to use both. Just use global variables or field variables
based on your preferences.</p>
<h2 id="inner-classes"><a class="header" href="#inner-classes">(Inner) Classes</a></h2>
<p>You can also define classes in a script, but note that such classes will be an inner class (its outer class being the script's class)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>Marcel provides arithmetic operators to work with numbers (+, -, /, * and soonish %)
but there are also operators that can be used on specific types.</p>
<p>We will explore all of them in this section</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plus-operator-"><a class="header" href="#plus-operator-">Plus operator (+)</a></h1>
<p>The plus operator is used for arithmetic and concatenating Strings, but in Marcel it also has other uses.</p>
<h2 id="add-collections"><a class="header" href="#add-collections">Add collections</a></h2>
<p>You can use <code>+</code> to add Collections. The two operand will not be modified. A new collection will be created with both operand
added to it.</p>
<p>It works well with lists</p>
<pre><code class="language-groovy">
list&lt;int&gt; myList1 = [1, 2, 3]
list&lt;int&gt; myList2 = [4, 5, 6]

list&lt;int&gt; myList3 = mySet1 + mySet2
println(myList3) // [1, 2, 3, 4, 5, 6]
</code></pre>
<p>and sets</p>
<pre><code class="language-groovy">
set&lt;int&gt; mySet1 = [1, 2, 3]
set&lt;int&gt; mySet2 = [3, 4, 5]

set&lt;int&gt; mySetUnion = mySet1 + mySet2
mySetUnion(myList3) // [1, 2, 3, 4, 5]
</code></pre>
<br/>
<p>You can also add different kind of collections. The type of the returned collection will be the same as the first operand</p>
<pre><code class="language-groovy">set&lt;int&gt; newSet = mySet1 + myList1
list&lt;int&gt; newList = myList1 + mySet1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minus-operator--"><a class="header" href="#minus-operator--">Minus operator (-)</a></h1>
<p>The minus operator is used for arithmetic but in Marcel it also has other uses.</p>
<h2 id="add-collections-1"><a class="header" href="#add-collections-1">Add collections</a></h2>
<p>You can use <code>-</code> to add Collections. The two operand will not be modified. A new collection will be created with the elements 
of the first operand having removed all elements from the second operand if any.</p>
<p>It works well with lists</p>
<pre><code class="language-groovy">
list&lt;int&gt; myList1 = [1, 2, 3]
list&lt;int&gt; myList2 = [3, 4, 5]

list&lt;int&gt; myList3 = mySet1 - mySet2
println(myList3) // [1, 2]
</code></pre>
<p>and sets</p>
<pre><code class="language-groovy">
set&lt;int&gt; mySet1 = [1, 2, 3]
set&lt;int&gt; mySet2 = [3, 4, 5]

set&lt;int&gt; mySetUnion = mySet1 - mySet2
println(mySetUnion) // [1, 2]
</code></pre>
<br/>
<p>You can also add different kind of collections. The type of the returned collection will be the same as the first operand</p>
<pre><code class="language-groovy">set&lt;int&gt; newSet = mySet1 - myList1
list&lt;int&gt; newList = myList1 - mySet1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h1>
<h2 id="equal-"><a class="header" href="#equal-">Equal (==)</a></h2>
<p>Unlike in Java <code>==</code> operator refers to the Object.equals() method (for objects comparison), and some custom comparison added (e.g. for collections).
This operator is null safe, meaning that if one of the operand is null, it won't throw a <code>NullPointerException</code>.</p>
<p>This operator works as described below</p>
<ul>
<li>if both operand are primitives, Java-like <code>==</code> is performed</li>
<li>if at least one of the two operand is an Object, the other operand is casted as an object if needed and the Marcel <code>==</code> is applied.</li>
</ul>
<p>The Marcel <code>==</code> works with the following rules</p>
<ul>
<li>if the first operand <strong>is</strong> the second operand (same instance), it returns true</li>
<li>if the left or the right operand is <code>null</code>, return false</li>
<li>if the two operand are arrays, return true if arrays content are the same</li>
<li>returns <code>operand1.equals(operand2)</code></li>
</ul>
<h2 id="not-equal-"><a class="header" href="#not-equal-">Not Equal (!=)</a></h2>
<p>The not equal apply is the negation of the Marcel's <code>==</code></p>
<h2 id="lt-loe-gt-goe----"><a class="header" href="#lt-loe-gt-goe----">LT, LOE, GT, GOE (&lt;, &lt;= ,&gt;, &gt;=)</a></h2>
<p>These operators works like in Java for primitive types. For object types, Marcel will check at compile-time if the first operand
has a <code>compareTo()</code> method and apply it on the second operand. The result of the compareTo will be used to apply the given comparison.</p>
<h2 id="is-same-instance-"><a class="header" href="#is-same-instance-">Is Same Instance (===)</a></h2>
<p>This operator is the Java's <code>==</code> operator for Objects. It will check if the two operand are the same instance.
(Note that it can't be used on primitives).</p>
<h2 id="is-not-same-instance-"><a class="header" href="#is-not-same-instance-">Is Not Same Instance (!==)</a></h2>
<p>It is the negation of the Is Same Instance operator.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexed-access-operator-exprindex"><a class="header" href="#indexed-access-operator-exprindex">Indexed Access Operator (expr[index])</a></h1>
<p>This operator is usually (or at least in Java) reserved for arrays, 
but in Marcel you can also use it to access lists. You can get/set 
items of your list using the same syntax as for an array</p>
<pre><code class="language-groovy">
list&lt;int&gt; list = [1, 2, 3]

println(list[0])

list[1] = 4
</code></pre>
<br/>
<p>You can also <a href="language-specification/operators/./operator-overloading.html">define your own accesses for custom types</a></p>
<h2 id="safe-indexed-access"><a class="header" href="#safe-indexed-access">Safe indexed access</a></h2>
<p>Similarly to <a href="language-specification/operators/./safe-navigation.html">safe navigation</a>, you can access elements of list/arrays</p>
<pre><code class="language-groovy">println(list?[5]) // will print null
</code></pre>
<p>This operator checks that the index provided is within range (<code>0 &lt;= index &lt; length</code>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="safe-navigation-operator-"><a class="header" href="#safe-navigation-operator-">Safe Navigation Operator (?.)</a></h1>
<p>The safe navigation operator is used to access a property of an object that might be null, without getting a <code>NullPointerException</code>.</p>
<p>It is a simple syntax allowing you to simple code. In Java, you could code</p>
<pre><code class="language-groovy">Foo foo = getFoo()
Bar bar = foo != null ? foo.getBar() : null
</code></pre>
<p>In Marcel, you would code</p>
<pre><code class="language-groovy">Foo foo = getFoo()
Bar bar = foo?.bar // Marcel recognize getters and translet '.bar' into '.getBar()' at compilation
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-custom-operators"><a class="header" href="#define-custom-operators">Define custom operators</a></h1>
<p>You can define operators in a very similar way as <a href="https://groovy-lang.org/operators.html#Operator-Overloading">groovy's</a>.</p>
<p>Each operator is associated to a function. To define an operator for a given type.</p>
<p>Here is the table of functions to define for each operator</p>
<h2 id="define-operators-from-extensions"><a class="header" href="#define-operators-from-extensions">Define operators from extensions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Method</th></tr></thead><tbody>
<tr><td>a + b</td><td>a.plus(b)</td></tr>
<tr><td>a - b</td><td>a.minus(b)</td></tr>
<tr><td>a * b</td><td>a.multiply(b)</td></tr>
<tr><td>a / b</td><td>a.div(b)</td></tr>
<tr><td>a &lt;&lt; b</td><td>a.leftShift(b)</td></tr>
<tr><td>a &gt;&gt; b</td><td>a.rightShift(b)</td></tr>
<tr><td>a[b]</td><td>a.getAt(b)</td></tr>
<tr><td>a[b, c, d]</td><td>a.getAt(b, c, d)</td></tr>
<tr><td>a?[b]</td><td>a.getAt(b)</td></tr>
<tr><td>a?[b]</td><td>a.getAt(b)</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="lambdas"><a class="header" href="#lambdas">Lambdas</a></h1>
<p>Marcel supports lambda expressions, but note that they are not compiled
to Java 8 lambdas, they are compiled to anonymous classes instead. This is to garanty
Android supports, as some Android device doesn't support full Java 8+ features.</p>
<h2 id="lambdas-with"><a class="header" href="#lambdas-with">Lambdas with</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extension-classes"><a class="header" href="#extension-classes">Extension classes</a></h1>
<p>Extension classes allows you to add methods to an existing class.</p>
<h2 id="how-to-declare"><a class="header" href="#how-to-declare">How to declare</a></h2>
<pre><code class="language-groovy">// MyExtension.mcl
extension class MyExtension for Integer {
  fun Integer next() {
    return this + 1
  }
}
</code></pre>
<p>The above example will add the method <code>next()</code> to the class Integer.</p>
<h2 id="how-to-use"><a class="header" href="#how-to-use">How to use</a></h2>
<p>Import your extension class with the <code>extension</code> keyword.</p>
<pre><code class="language-groovy">// another file
import extension MyExtension

Integer a = 1
println(a.next())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-objects"><a class="header" href="#dynamic-objects">Dynamic Objects</a></h1>
<p>Dynamic objects a little dynamic feature in Marcel. They allow you to evaluate dynamically property/operator calls instead of
at compile time.</p>
<p>E.g.</p>
<pre><code class="language-groovy">DynamicObject o = DynamicObject.of(1)
println(o[1]) // will throw MissingMethodException at runtime, instead of a semantic error at compile time
</code></pre>
<p>But the following code will run without throwing any exception</p>
<pre><code class="language-groovy">DynamicObject o = DynamicObject.of([1, 2, 3] as list&lt;int&gt;)
println(o[1]) // will print 2
</code></pre>
<p>DynamicObject could potentially handle dynamic method calls and handle properties, but this is <strong>not</strong> done as Marcel
is not designed to be a dynamic language in the first place.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<p>This section describes the different tools to take your Marcel experience to the next level.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="marcl"><a class="header" href="#marcl">Marcl</a></h1>
<p>MarCL (MARcel Command Line tool) is useful to compile/execute marcel source files.</p>
<p>Let's explore all the commands it provides</p>
<h2 id="execute"><a class="header" href="#execute">Execute</a></h2>
<p>This is the default command, meaning that if you don't specify a command, it will
use this one.</p>
<pre><code class="language-text">Usage: marcl execute [OPTIONS] FILE [SCRIPT_ARGUMENTS]...

  Execute a marcel script

Options:
  -c, --keep-class         keep compiled class files after execution
  -j, --keep-jar           keep compiled jar file after execution
  -p, --print-stack-trace  print stack trace on compilation error
  -h, --help               Show this message and exit
</code></pre>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><code class="language-shell">marcl execute script.mcl
</code></pre>
<pre><code class="language-shell">marcl -c script.mcl
</code></pre>
<pre><code class="language-shell">marcl execute -cj script.mcl myScriptArg1 myScriptArg2
</code></pre>
<h2 id="compile"><a class="header" href="#compile">Compile</a></h2>
<pre><code class="language-text">Usage: marcl compile [OPTIONS] FILE

  Compiles a Marcel class to a .class file and/or .jar file

Options:
  -c, --class              Compile to class
  -j, --jar                Compile to jar
  -p, --print-stack-trace  print stack trace on compilation error
  -h, --help               Show this message and exit

</code></pre>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<pre><code class="language-shell">marcl compile script.mcl
</code></pre>
<pre><code class="language-shell">marcl compile -cj script.mcl
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="marshell"><a class="header" href="#marshell">Marshell</a></h1>
<p>Marshell is a shell that can be used to run marcel instructions, on the fly. It is
a Read Eval Print Loop tool.</p>
<p>It is the equivalent of <a href="https://groovy-lang.org/groovysh.html">groovysh</a> for Marcel.</p>
<p>This shell supports syntax highlighting and also highlights defined functions/variables.</p>
<h2 id="define-variables"><a class="header" href="#define-variables">Define variables</a></h2>
<p>In marshell, you can't have <a href="tools/../language-specification/source-file-structure/script.html#fields">class fields</a>, <strong>but</strong> you can use global variables.
To de clare a global variable, just assign to a variable a value, without specifying its type</p>
<pre><code class="language-groovy">a = 1 // this will create a global variable a
</code></pre>
<p>Global variables can't change type. Meaning that after having defining one, you can't assign to it
a value that is of an incompatible type of the one you used when you first assigned it a value.</p>
<p>To specify explicitly the type of the global variable, use the <code>as</code> keyword.</p>
<pre><code class="language-groovy">a = [1, 2] as set&lt;int&gt;
</code></pre>
<h2 id="define-functions"><a class="header" href="#define-functions">Define functions</a></h2>
<p>Define functions as you would in a Marcel script</p>
<h2 id="define-classes"><a class="header" href="#define-classes">Define classes</a></h2>
<p>Define classes as you would in a Marcel script. All defined classes are top-level classes (they
are not inner class as they would be in a Marcel script).</p>
<h2 id="run-commands"><a class="header" href="#run-commands">Run commands</a></h2>
<p>Marshell has some specific commands make your experience even better.</p>
<p>Use the <code>:help</code> command to see all the commands (marshell-specific instructions) you can run</p>
<h2 id="import-dependencies"><a class="header" href="#import-dependencies">Import dependencies</a></h2>
<p>You can import dependencies on the fly with the <code>:pull</code> command</p>
<pre><code class="language-text">marshell:000&gt; :pull com.google.code.gson:gson:2.10.1
marshell:000&gt; :import com.google.gson.Gson
marshell:000&gt; gson = new Gson()
</code></pre>
<h2 id="initialisation-script"><a class="header" href="#initialisation-script">Initialisation script</a></h2>
<p>If you want to always load some data everytime you run marshell, you can create a
script in <code>$MARCEL_HOME/marshell/init.mcl</code>.</p>
<p>In this script you <strong>can't</strong> use marcel commands. If you want to import a dependency/dumbbell,
just do it like you would in a normal marcel script (<code>import ...</code> or <code>dumbbell '...'</code>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="marshell-for-android"><a class="header" href="#marshell-for-android">Marshell for Android</a></h1>
<p><strong>Coming soon(-ish)</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dumbbell---marcels-dependency-manager"><a class="header" href="#dumbbell---marcels-dependency-manager">Dumbbell - Marcel's dependency manager</a></h1>
<p>Dumbbell is a dependency manager for Marcel. It allows you to easily import dependencies in your scripts,
without having to create a Maven/Gradle project.</p>
<p>It was inspired strongly from <a href="https://groovy-lang.org/grape.html">Groovy's grapes</a></p>
<br/>
<h2 id="import-dependencies-in-a-script"><a class="header" href="#import-dependencies-in-a-script">Import dependencies in a script</a></h2>
<p>To import a dependency, use the <code>dumbbell</code> keyword.</p>
<pre><code class="language-groovy">dumbbell 'com.google.code.gson:gson:2.8.6'
import com.google.gson.Gson

Gson gson = new Gson()

println(gson.toJson(['a': 'b']))
</code></pre>
<p>Dependencies are pulled from Maven central. The list of repository to pull from will be configurable (someday).</p>
<p>Note that this feature <strong>only works when running scripts with <a href="tools/./marcl.html">MarCL</a></strong>.</p>
<h2 id="import-dependencies-in-marshell"><a class="header" href="#import-dependencies-in-marshell">Import dependencies in Marshell</a></h2>
<p>Dumbbell is also used in <a href="tools/./marshell.html">Marshell</a>. Use the <code>:pull</code> command to pull 
dependencies dynamically.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intelij-plugin-for-marcel"><a class="header" href="#intelij-plugin-for-marcel">IntelIJ Plugin for Marcel</a></h1>
<p>You can find a plugin to support Marcel on the below link</p>
<p><a href="https://github.com/tambapps/marcel-intelij-plugin">marcel-intelij-plugin</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<p>In this section, you'll find all sort of tutorials explaining
how to implement a given pattern (or play with a given feature) in Marcel.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<p>Marcel's <a href="tutorials/../language-specification/syntax/literal-values.html#pattern-strings">Pattern strings</a>
allows you to create pattern in a simple manner. When you add that with the <a href="tutorials/../language-specification/operators/find.html">find operator</a>,
matching with regular expression has never been this easy.</p>
<pre><code class="language-groovy">Pattern pattern = /Hello (\w+)/; // semi-colon required because of pattern flags
Matcher matcher = &quot;Hello you&quot; =~ pattern
println(matcher.matches())
</code></pre>
<p>The above code tests is the String <code>Hello you</code> matches the pattern <code>Hello (\w+)</code>.</p>
<h2 id="extract-groups-from-a-pattern"><a class="header" href="#extract-groups-from-a-pattern">Extract groups from a pattern</a></h2>
<p>With Marcel's <a href="tutorials/../language-specification/variables.html#multiple-declarations">multiple variable declaration</a>, you can extract
matched groups in the following way</p>
<pre><code class="language-groovy">def (String wholeMatch, String groupMatch) = (&quot;Hello you&quot; =~ /Hello (\w+)/).groups() // method from the Marcel Development Kit
</code></pre>
<p>In some case, you might not care about the whole match (you just want the groups you declared in your regex).
If that's so you can ignore it like this</p>
<pre><code class="language-groovy">def (_, String groupMatch) = (&quot;Hello you&quot; =~ /Hello (\w+)/).groups()
</code></pre>
<p>Wait for it, there's an even better way to do that</p>
<pre><code class="language-groovy">def (String groupMatch) = (&quot;Hello you&quot; =~ /Hello (\w+)/).definedGroups()
</code></pre>
<p>The defined groups only return the groups you defined in the regex, and therefore skip the group corresponding to the whole match.</p>
<h2 id="truthy-pattern-declaration"><a class="header" href="#truthy-pattern-declaration">Truthy pattern declaration</a></h2>
<pre><code class="language-groovy">Pattern pattern = /Hello (\w+)/;

if (&quot;yellow me&quot; =~ pattern) {
  println(&quot;It matched????&quot;)
}

if (Matcher m = &quot;Hello me&quot; =~ pattern) {
  println(&quot;It matched&quot; + m.group(1))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="marcel-in-action"><a class="header" href="#marcel-in-action">Marcel In Action</a></h1>
<p>Here are example of projects using marcel</p>
<ul>
<li><a href="https://github.com/tambapps/advent-of-code">Tambapps's Advent Of Code</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
