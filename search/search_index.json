{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Marcel, a simple and efficient programming language for any JVM","text":"<p>Marcel is a programming language built with the following goals in mind: - Being simple, not too verbose, allowing to write programs quickly - Runnable on Android devices (this language is guaranteed to be compilable and executable on Android devices)</p> <p>Its features are inspired from many languages such as Groovy, Kotlin, Perl and Dart. You can consult the source code of this language on GitHub</p> <p></p> <p>Marcel compiles to Java bytecode (.class files). You can execute marcel script/projects on any JVMs (17+), as long as the Marcel stdlib is included in your classpath.</p> <p>As stated above, marcel is guaranteed to be compilable and executable on any Android devices running on Android 11 or +. You can install the Marcel for Android app to develop, compile and execute Marcel programs.</p> <p> </p>"},{"location":"asynchronous-programming/","title":"Asynchronous programming in Marcel","text":"<p>This feature is currently under development and is therefore not available yet.</p> <p>Marcel provides an async/await paradigm allowing to execute tasks in the backgrounds. In Marcel, asynchronous (AKA <code>async</code>) code will be executed on background threads (virtual threads if you JRE supports it).</p>"},{"location":"asynchronous-programming/#usage","title":"Usage","text":""},{"location":"asynchronous-programming/#async-functions","title":"Async functions","text":"<p>Async functions provide a way to write functions that are executed in the background when called</p> <pre><code>async fun int compute() {\n  Thread.sleep(2000l)\n  return 1\n}\n</code></pre> <p>The actual return type of async functions are Futures (in above example a <code>Future&lt;Integer&gt;</code>).</p>"},{"location":"asynchronous-programming/#async-block","title":"Async block","text":"<p>An <code>async</code> code block is a block in which you can perform async operations</p> <pre><code>async fun int doCompute() -&gt; 1\n\nasync {\n  int result = await(doCompute())\n  result\n}\n</code></pre> <p><code>async</code> blocks will always wait (at the end) for all asynchronous tasks to complete. Although this is done automatically, you can also do it manually with the <code>await</code> function.</p>"},{"location":"asynchronous-programming/#async-context","title":"Async context","text":"<p>It's important to know that async functions can only be executed in an async context., that is in an async function or in an async block (we'll get on that later).</p>"},{"location":"asynchronous-programming/#await","title":"Await","text":"<p>The <code>await</code> keyword allows to wait for the result of an asynchronous function.</p> <pre><code>async fun int computeInBackground() {\n  int result = await doCompute()\n  println(result)\n}\n</code></pre> <p>There are many ways to await an asynchronous process.</p>"},{"location":"asynchronous-programming/#await_1","title":"await","text":"<p>Await is (a set of) static methods that you can use in <code>async</code> contexts.</p>"},{"location":"asynchronous-programming/#await_2","title":"await()","text":"<p>Awaits for all asynchronous tasks to complete.</p>"},{"location":"asynchronous-programming/#awaitfuture","title":"await(Future)","text":"<p>Awaits for a particular asynchronous task to complete.</p>"},{"location":"asynchronous-programming/#awaitcollection-awaitobject","title":"await(Collection), await(Object[])","text":"<p>Awaits for a collection/array of asynchronous tasks to complete.</p>"},{"location":"asynchronous-programming/#awaitawaitprogresslistener","title":"await(AwaitProgressListener)","text":"<p>Awaits using the provider lambda to listen to progress update. E.g.</p> <pre><code>async {\n  doCompute()\n  await { int completedTasks, int total -&gt; \n    print(\"\\rComputed $completedTasks out of $total configurations\")\n  }\n}\n</code></pre> <p>E.g. the below code example wouldn't compile</p> <pre><code>async fun int doCompute() -&gt; 1\n\nfun void computeInBackground() {\n  int result = await doCompute() // Compiler error: cannot call async function in a non async context\n  println(result)\n}\n</code></pre>"},{"location":"asynchronous-programming/#under-the-hood-of-async-programming","title":"Under the Hood of Async Programming","text":"<p>The library implementing asynchronous programming in Marcel is Threadmill, a subproject of Marcel.</p>"},{"location":"asynchronous-programming/#how-async-processes-are-executed","title":"How async processes are executed","text":"<p>Calling an asynchronous function will actually supply a new Callable to an executor and return the resulting Future.</p> <p>Executing an <code>async</code> block will actually supply a new <code>Runnable</code> to the executor in order to execute the block in the background.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>In this section, we'll discuss :</p> <ul> <li>Installing Marcel</li> <li>Writing and running a Marcel program that prints <code>Hello World</code></li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Marcel comes with :</p> <ul> <li>marcl</li> <li>marshell</li> <li>dumbbell</li> </ul>"},{"location":"getting-started/#install-from-release","title":"Install from release","text":""},{"location":"getting-started/#using-the-script","title":"Using the script","text":"<p>You can run the below command in order to install a Marcel release in a specific directory.</p> <pre><code>curl -s https://raw.githubusercontent.com/tambapps/marcel/main/install/install-from-release.sh | bash -s\n</code></pre> <p>It will install Marcel in the <code>$HOME/.marcel</code> folder.</p> <p>You can also specify a directory by passing it as an argument as shown below</p> <pre><code># Will install in ./my-folder\ncurl -s https://raw.githubusercontent.com/tambapps/marcel/main/install/install-from-release.sh | bash -s ./my-folder\n</code></pre>"},{"location":"getting-started/#downloading-the-release","title":"Downloading the release","text":"<p>You can download the <code>release.zip</code> of a Marcel Release. Unzip it where you want.</p>"},{"location":"getting-started/#set-marcel_home","title":"Set MARCEL_HOME","text":"<p>Set the <code>MARCEL_HOME</code> environment to the path of the release you just unzipped. You can set it in your <code>.bashrc</code> or <code>.zshrc</code> so that this variable is set in all your sessions. You can also add <code>$MARCEL_HOME/bin</code> to your <code>PATH</code> so your shell recognize marcel commands.</p>"},{"location":"getting-started/#install-from-source-code","title":"Install from source code","text":"<p>There is a script in marcel repository for that.</p> <p>Note that this script only works on Linux and Mac and requires Maven being installed.</p> <pre><code>git clone https://github.com/tambapps/marcel.git\ncd marcel\n./install/install-from-source.sh\n</code></pre>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>You'll need Maven for the installation.</p>"},{"location":"getting-started/#run-script","title":"Run script","text":"<p>Clone the repository</p> <pre><code>git clone https://github.com/tambapps/marcel.git\ncd marcel\n</code></pre> <p>And then run the script</p> <pre><code>./install-from-source.sh\n</code></pre> <p>The script basically runs a lot of <code>mvn clean package</code> and then copy/create some files in <code>$HOME/.marcel/</code>.</p> <p>Lastly, you can add the following lines into your <code>$HOME/.bashrc</code> (or <code>$HOME/.zshrc</code> or whatever) to easily use marcel tools</p> <pre><code>MARCEL_HOME=\"$HOME/.marcel\"\nPATH=\"$PATH:$MARCEL_HOME/bin\"\n</code></pre>"},{"location":"getting-started/#hello-world","title":"Hello World","text":"<p>Let's dive in some code now. Marcel can be used as a scripting language, so you don't need to declare a <code>main()</code> function if you just want to run some code.</p> <pre><code>// HelloWorld.mcl\nprintln(\"Hello World!\")\n</code></pre> <p>That's it! One line is all it takes to write the famous Hello World program.</p> <p>To execute it, use marcl.</p> <pre><code>marcl HelloWorld.mcl\n</code></pre>"},{"location":"marcel-in-action/","title":"Marcel In Action","text":"<p>Here are some use-cases of Marcel.</p>"},{"location":"marcel-in-action/#advent-of-code","title":"Advent of code","text":"<p>Checkout Tambapps's Advent Of Code</p>"},{"location":"marcel-in-action/#fibonacci-suite","title":"Fibonacci suite","text":"<p>Here is an implementation of the Fibonacci suite in Marcel.</p> <pre><code>println(fibonacci(10))\n\nfun int fibonacci(int n) {\n  return switch (n) {\n    0, 1 -&gt; n\n    else -&gt; fibonacci(n - 1) + fibonacci(n - 2)\n  }\n}\n</code></pre> <p>But this implementation takes a lot of time when using large <code>n</code> values. A way to solve this problem would be to cache fibonnaci's results, which can be done using the @cached annotation</p> <pre><code>println(fibonacci(10))\n\n@cached\nfun int fibonacci(int n) -&gt; switch (n) {\n  0, 1 -&gt; n\n  else -&gt; fibonacci(n - 1) + fibonacci(n - 2)\n}\n</code></pre>"},{"location":"guides/collections/","title":"Collections","text":"<p>In this section we'll explore ways to use Marcel Collections APIs enhancements</p>"},{"location":"guides/collections/#literals","title":"Literals","text":"<p>You can declare collections using the literal array syntax as shown below </p> <pre><code>List&lt;int&gt; ints = [1, 2, 3, 4]\nList list = [1 new Object(), 1..2]\n\n\nSet&lt;char&gt; chars = [`A`, `C`, `B`, `D`]\n</code></pre>"},{"location":"guides/collections/#operate-on-collections-and-arrays","title":"Operate on Collections and Arrays","text":"<p>Collections and Arrays have useful functions allowing you to operate on them</p>"},{"location":"guides/collections/#map","title":"map","text":"<p>This operator allows you to map each element of the collection to another.</p> <pre><code>List&lt;int&gt; ints = [1, 2, 3]\nList&lt;float&gt; floats = ints.mapToFloat { it + 1f } // mapping to another collection of primitive\nint[] intArray = [3, 4, 5, 6]\nList&lt;int&gt; otherInts = intArray.mapToInt { it - 1 }\n\nList list = ints.map { new Foo(list) }\n// specified type explicitely\nList list2 = list.map { Foo foo -&gt; foo.bar }\n</code></pre> <p>Note that for collections of primitive you don't have to specify explicitly your parameter's type.  But for non-primitive lists, as Marcel doesn't support generic types, you'll have to explicitly  declare your lambda's arguments.</p>"},{"location":"guides/collections/#find-findall","title":"find, findAll","text":"<p>The <code>find</code> operator finds and return the first element of the collection/array matching the provided predicate (or null if no element matched).</p> <p><code>findAll</code> returns a list of all elements matching the given predicate</p> <pre><code>Set&lt;int&gt; ints = [1, 2, 3]\nint myInt = ints.find { it == 2 }\nint[] intArray = [3, 4, 5, 6]\nint myInt2 = intArray.find { it == 5 }\nList&lt;int&gt; myInts = ints.findAll { it &gt;= 2 }\n\n\nList list = [1..1, 2..3, 3..4]\nIntRange myRange = list.find { IntRange range -&gt; range.contains(4) }\nList myRanges = list.findAll { IntRange range -&gt; range.contains(2) }\n</code></pre>"},{"location":"guides/collections/#any-all-none","title":"any, all, none","text":"<p>Those operations return booleans. - any returns true if at least one element of the collection/array matches the given predicate - all returns true if all elements of the collection/array matche the given predicate - none returns true if all elements of the collection/array does not match the given predicate</p>"},{"location":"guides/command-line-arguments/","title":"Command Line options/arguments","text":"<p>Marcel provides utilities to parse command-line options and arguments.</p> <p>All classes referenced in this guide are available under the package <code>marcel.io.clargs</code>.</p>"},{"location":"guides/command-line-arguments/#options-vs-arguments","title":"Options VS Arguments","text":"<p>When running a script, there are options and arguments. The arguments of your programs are the value passed, not assigned to any name, whereas the options are values assigned to specific names.</p> <p>For example, in the example below</p> <pre><code>marcl script.mcl -d 1 -n \"a value\" arg1 arg2 arg3\n</code></pre> <p>There is - the option <code>d=1</code> - the option <code>n=\"a value\"</code> - the arguments <code>arg1</code>, <code>arg2</code>, <code>arg3</code></p>"},{"location":"guides/command-line-arguments/#define-options","title":"Define options","text":"<p>An option can be defined as a field, annotated with <code>@Option</code>.</p> <pre><code>@Option\nprivate int depth;\n</code></pre> <p>The above piece of code declares an option named <code>depth</code>.</p>"},{"location":"guides/command-line-arguments/#specify-option-names","title":"Specify option names","text":"<p>You can specify short and/or long name of your option through the annotation.</p> <pre><code>@Option(shortName = \"d\", longName = \"depth\")\nprivate int depth\n</code></pre> <p>The difference between short and long names are how you specify the option when running the script. Short name are to be specified with only one dash, whereas long names are to be specified with 2.</p> <p>E.g.</p> <pre><code>marcl script.mcl -d 1\nmarcl script.mcl --depth 1\n</code></pre> <p>When no longName was specified, Marcel fallbacks to the name of the annotated field.</p>"},{"location":"guides/command-line-arguments/#optional-options-and-default-values","title":"Optional options and default values","text":"<p>By default an option is required. You can change this behaviour by marking it as <code>required = false</code> or by giving it a default value.</p> <pre><code>@Option(required = false)\nprivate int depth\n\n@Option\nprivate int depth2 = 5 // not required as it has a default value\n</code></pre> <p>As you can see above, you can specify the default value of an option by assigning a value to a field.</p> <p>Note that for <code>null</code> or 0 values, you'll still need to explicitly specify the <code>required = false</code> flag in order for the option to be optional.</p>"},{"location":"guides/command-line-arguments/#multivalued-options","title":"Multivalued options","text":"<p>Sometimes you may want an option to be specifiable multiple times. In such case you'll need to declare the field as a Collection. List and Sets (even of primitives) are supported.</p> <p>for example the below example allows to specify multiple <code>depth</code></p> <pre><code>@Option(shortName = \"d\", longName = \"depth\", arity = \"*\")\nprivate List&lt;int&gt; depths\n</code></pre> <p>As Marcel doesn't really support generic types, you must use the <code>elementsType</code> annotation property to specify the wanted type of the multivalued option.</p> <pre><code>@Option(shortName = \"d\", longName = \"depth\", elementsType = BigDecimal.class, arity = \"*\")\nprivate List&lt;BigDecimal&gt; depths\n</code></pre> <p>The <code>arity</code> annotation property is a String specifying how many arguments there can be for the given option (defaults to 1). It supports many formats: - <code>*</code> corresponds to any arity (0, or more) - a range, like 2..5 (from 2 inclusive to 5 inclusive) - a range with one infinite bound. E.g. 2.. for at least 2, or ..4 for at most 4 - a number n followed be a '+' to specify at least n (e.g. 5+) - a number, for exactly n arguments</p>"},{"location":"guides/command-line-arguments/#conversion","title":"Conversion","text":"<p>Marcel supports argument of the following types - all primitive types and their object wrapper class - String - BigInteger - BigDecimal - File - Path - Enum classes</p> <p>You can declare an option field of one of the above type, and Marcel will automatically know how to convert the option's value (String) into the target type.</p> <p>For other types, you can specify a custom <code>converter</code> as shown below</p> <pre><code>@Option(converter = { String s -&gt; Duration.parse(s) })\nprivate Duration duration\n</code></pre> <p>You can throw an <code>IllegalArgumentException</code> in those lambda to specify that the option value is incorrect.</p> <p>Yes, in Marcel (like in Groovy) you can specify lambdas as an annotation attribute value.</p>"},{"location":"guides/command-line-arguments/#multivalued-options_1","title":"Multivalued options","text":"<p>for Multi-valued options, Marcel supports - List - Set - all list/set of primitives</p> <p>But as Marcel does not support generic types if you declare a field as a List/Set (Java's List/Set, not of primitives), it will put the raw value as a String in it.</p> <p>You can still specify a custom <code>converter</code> for such options, it will be applied on each value of the option.</p> <p>Let's look at the below options</p> <pre><code>@Option(longName = \"int\", arity = '*') // no need for a converter as it is a list of primitive ints\nprivate List&lt;int&gt; ints\n@Option(longName = \"duration\", arity = '*', converter = { String s -&gt; Duration.parse(s) })\nprivate List durations\n</code></pre> <p>For the command</p> <pre><code> marcl Test.marcel -duration PT1S PT1M -int 1 -int 2 -int 3\n</code></pre> <p>We will have <code>ints = [1, 2, 3]</code> and <code>durations = [PT1S, PT1M]</code>.</p>"},{"location":"guides/command-line-arguments/#value-separator","title":"Value separator","text":"<p>As seen above, we provide multiple values to a multivalued option by using multiple times the same option,  but there is another way to pass those: using a <code>valueSeparator</code>.</p> <p>The value separator will force the user to pass all the values of the option at once, separated by the <code>valueSeparator</code>.</p> <p>For example, the option</p> <pre><code>@Option(longName = \"int\", arity = '*', valueSeparator = ',')\nprivate List&lt;int&gt; ints\n</code></pre> <p>with the command</p> <pre><code> marcl Test.marcel -int 1,2,3\n</code></pre> <p>Will result in <code>ints = [1, 2, 3]</code>.</p>"},{"location":"guides/command-line-arguments/#validator","title":"Validator","text":"<p>Sometimes you may want to add validation to an option. You can do so by specifying a lambda under the <code>validation</code> annotation parameter. Any <code>IllegalArgumentException</code> thrown in this lambda will be considered as a validation error.</p> <pre><code>@Option(shortName = \"n\", validator = { int n -&gt;\n    if (n % 2 != 0) throw new IllegalArgumentException(\"n should be even\")\n  })\nprivate int number\n</code></pre>"},{"location":"guides/command-line-arguments/#help-option","title":"Help option","text":"<p>You can use the <code>@HelpOption</code> annotation on a <code>boolean</code> field to specify an option that should print usage and then exit the program  (this behaviour is handled automatically by the <code>ClArgs.init(...)</code> method), as shown below.</p> <pre><code>@HelpOption\nprivate boolean help\n</code></pre>"},{"location":"guides/command-line-arguments/#define-arguments","title":"Define arguments","text":"<p>You can assign the arguments values to a field thanks to the <code>@Arguments</code> annotation.</p> <pre><code>@Arguments\nprivate List args\n</code></pre>"},{"location":"guides/command-line-arguments/#arguments-conversion-and-validation","title":"Arguments conversion and validation","text":"<p>This annotation also has the <code>elementsType</code>, <code>converter</code> and <code>validator</code> annotation properties allowing you to customize the parsing/validation.</p>"},{"location":"guides/command-line-arguments/#parse-options-and-arguments","title":"Parse options and arguments","text":"<p>After having declared the options and/or arguments, we want to assign them values based on the command line arguments passed to execute the script.</p> <p>This can be done with one line</p> <pre><code>ClArgs.init(this, args)\n</code></pre> <p>This line of code will parse the command line <code>args</code> and assign the appropriate values to your options.</p> <p>In more details it will - parse the command line arguments - if any error occurred (e.g. arity not respected, type not respected, validation error): print the error, print the usage of this script, and then exit (<code>System.exit(1)</code>) - if no error occurred, you option fields are ready to be used</p>"},{"location":"guides/command-line-arguments/#document-the-usage-of-your-script","title":"Document the usage of your script","text":"<p>We've seen that the usage of your script will be printed in case of error.  You can provide more data to annotations and the <code>ClArgs.init(...)</code> method call in order to print a well explained usage.</p>"},{"location":"guides/command-line-arguments/#option-description","title":"Option description","text":"<p>Use the <code>description</code> annotation parameter to describe what your option does</p> <pre><code>@Option(description = \"the max depth at which to search files\")\nprivate int depth\n</code></pre>"},{"location":"guides/command-line-arguments/#customize-usage","title":"Customize usage","text":"<p>The <code>ClArgs.init(...)</code> has several optional arguments allowing to enrich the <code>usage</code> message.</p>"},{"location":"guides/command-line-arguments/#usage","title":"usage","text":"<p>Usage summary displayed as the first line.</p>"},{"location":"guides/command-line-arguments/#header","title":"header","text":"<p>Optional additional message for usage; displayed after the usage summary but before the options are displayed.</p>"},{"location":"guides/command-line-arguments/#footer","title":"footer","text":"<p>Optional additional message for usage; displayed after the options are displayed.</p>"},{"location":"guides/command-line-arguments/#full-example","title":"Full example","text":"<p>Take a look at the below script.</p> <pre><code>import marcel.io.clargs.*\nimport java.time.Duration\n\n@Option(shortName = \"d\", validator = { int d -&gt;\n    if (d &lt;= 0) throw new IllegalArgumentException(\"should be positive\")\n  }, description = \"The depth limit of the search\")\nprivate int depth = 100\n\n@Option(shortName = \"n\", description = \"The name to search\")\nprivate String name\n\n@Option(shortName = \"i\", longName = \"ignore-case\", description = \"whether to ignore case when matching the name\", required = false)\nprivate boolean ignoreCase\n\n\n@HelpOption\nprivate boolean help\n\n@Arguments\nprivate List filePaths\n\nClArgs.init(this, args, usage: 'marcl script.mcl')\n\n// process options and arguments\n</code></pre> <p>The usage of this script would result as shown below</p> <pre><code>usage: marcl script.mcl ARGUMENTS\n -d,--depth &lt;arg&gt;   The depth limit of the search. default: 100\n -h,--help          Prints usage information\n -i,--ignore-case   whether to ignore case when matching the name. default: false\n -n,--name &lt;arg&gt;    The name to search\n</code></pre>"},{"location":"guides/csv/","title":"Parsing and producing CSV","text":"<p>Marcel comes with integrated support for converting between Marcel objects and CSV. The classes dedicated to CSV parsing are found in the <code>marcel.csv</code> package.</p> <p>The CSV (de)serialization is backed by OpenCSV. All is handled by the <code>DynamicCsv</code> class.</p>"},{"location":"guides/csv/#parsing-csv","title":"Parsing CSV","text":"<p>The parsing of CSV takes advantage of Dynamic Objects to make the API easy to use.</p> <p>Here is an example:</p> <pre><code>import marcel.csv.*\n\nList companies;\n// with headers to parse the first line of the CSV as the field names\ntry (CsvReader reader = DynamicCsv.reader(new File('companies.csv'), withHeader: true)) {\n  companies = [\n    for dynobj line in reader -&gt; line.companyName \n      if line.keywords.asString().split(',').find { it == 'Java' } \n  ]\n}\nprintln(companies)\n</code></pre> <p>You can also access a line's values by index:</p> <pre><code>import marcel.csv.*\n\nList companies = []\ntry (CsvReader reader = DynamicCsv.reader(new File('companies.csv'))) {\n  while (dynobj line = reader.readNext()) {\n    if (line[2].asString().split(',').find { it == 'Java' }) {\n      companies &lt;&lt; line[0]\n    }\n  }\n}\nprintln(companies)\n</code></pre> <p>There are many optional parameters to the <code>reader()</code> methods: - separator: the separator character of the CSV (defaults to <code>,</code>) - quoteChar: the quote character of the CSV (defaults to <code>\"</code>) - escapeChar: the escape character (defaults to <code>\\</code>) - withHeader: whether the first line should be considered as an header and parsed automatically (defaults to <code>false</code>) - strictQuotes: whether to ignore characters outside the quotes (defaults to <code>false</code>)</p> <p>Here is the CSV used for the above examples</p> <pre><code>companyName,website,keywords,nbEmployees\nCompany A,https://company.a.fr,\"Java, Spring Boot\",10\nCompany B,https://company.b.fr,\"Javascript\",5000\nCompany C,https://company.c.fr,\"Java, Quarkus\",250\nCompany D,https://company.d.fr,\"Python\",43\n</code></pre>"},{"location":"guides/csv/#producing-csv","title":"Producing CSV","text":"<p>Writing a CSV is pretty much straight-forward</p> <pre><code>import marcel.csv.*\nList companies;\n\ntry (CsvWriter writer = DynamicCsv.writer(new File('output.csv'))) {\n  writer.write(['companyName','website','keywords','nbEmployees'])\n  writer.write(List.of(\"company A\", \"http://company.a/\", 5))\n  writer.write(DynamicObject.of([\"Company B\",\"https://company.b.fr\",\"Javascript\",5000]))\n  writer.write([\"company, C\", \"http://company.c/\", IntRanges.of(1, 10)])\n}\n</code></pre> <p>There are many optional parameters to the <code>writer()</code> methods: - separator: the separator character of the CSV (defaults to <code>,</code>) - quoteChar: the quote character of the CSV (defaults to <code>\"</code>) - escapeChar: the escape character (defaults to <code>\\</code>) - applyQuotesToAll: whether all cells should be quoted even when not necessary (defaults to <code>false</code>)</p>"},{"location":"guides/json/","title":"Parsing and producing JSON","text":"<p>Marcel comes with integrated support for converting between Marcel objects and JSON.  The classes dedicated to JSON serialization and parsing are found in the <code>marcel.json</code> package.</p> <p>The JSON (de)serialization is backed by Jackson.</p> <p>All is handled by the <code>DynamicJson</code> class. It takes advantage of Dynamic Objects to make this API easy to use.</p> <pre><code>import marcel.json.*\n\n\ndynobj json = DynamicJson.instance.read('{\"id\": 0, \"name\": \"Something\", \"tags\": [\"fun\", \"adventure\", \"friendship\"], \"metadata\": {\"foo\": \"bar\"}}')\nprintln(json['name'] == json.name) // true\nprintln(json.tags[2]) // friendship\nprintln(json.metadata.foo) // bar\nprintln(json.id.asInt() + 1) // 1\n\njson.name = \"Something Else\"\n\nprintln(DynamicJson.instance.writeAsString(json)) // {\"metadata\":{\"foo\":\"bar\"},\"name\":\"Something Else\",\"id\":0,\"tags\":[\"fun\",\"adventure\",\"friendship\"]}\n// use writeAsPrettyString to write a pretty indented JSON string\n\nDynamicJson.instance.write([json], new File('output.json')) // write json list in file\n</code></pre>"},{"location":"guides/regular-expressions/","title":"Regular Expressions (Pattern Matching)","text":"<p>Marcel's Pattern strings allows you to create pattern in a simple manner. When you add that with the find operator, matching with regular expression has never been this easy.</p> <pre><code>Pattern pattern = r/Hello (\\w+)/; // semi-colon required because of pattern flags\nMatcher matcher = \"Hello you\" =~ pattern\nprintln(matcher.matches())\n</code></pre> <p>The above code tests is the String <code>Hello you</code> matches the pattern <code>Hello (\\w+)</code>.</p>"},{"location":"guides/regular-expressions/#extract-groups-from-a-pattern","title":"Extract groups from a pattern","text":"<p>With Marcel's multiple variable declaration, you can extract matched groups in the following way</p> <pre><code>def (String wholeMatch, String groupMatch) = (\"Hello you\" =~ r/Hello (\\w+)/).groups() // method from the Marcel Development Kit\n</code></pre> <p>In some case, you might not care about the whole match (you just want the groups you declared in your regex). If that's so you can ignore it like this</p> <pre><code>def (_, String groupMatch) = (\"Hello you\" =~ r/Hello (\\w+)/).groups()\n</code></pre> <p>Wait for it, there's an even better way to do that</p> <pre><code>def (String groupMatch) = (\"Hello you\" =~ r/Hello (\\w+)/).definedGroups()\n</code></pre> <p>The defined groups only return the groups you defined in the regex, and therefore skip the group corresponding to the whole match.</p>"},{"location":"guides/regular-expressions/#truthy-pattern-declaration","title":"Truthy pattern declaration","text":"<pre><code>Pattern pattern = r/Hello (\\w+)/;\n\nif (\"yellow me\" =~ pattern) {\n  println(\"It matched????\")\n}\n\nif (Matcher m = \"Hello me\" =~ pattern) {\n  println(\"It matched\" + m.group(1))\n}\n</code></pre>"},{"location":"guides/stdlib-extensions/","title":"Standard Library extensions","text":"<p>In this section we'll take a look at the extensions Marcel stdlib provides.</p> <p>To understand how extensions work, you can consult the related page.</p>"},{"location":"guides/stdlib-extensions/#automatically-imported-extensions","title":"Automatically imported extensions","text":"<p>Marcel imports by default a large panel of extensions, which you can consult under the DefaultMarcelMethods class.</p> <p>There are also methods defined in separate classes.</p>"},{"location":"guides/stdlib-extensions/#character-extensions","title":"Character extensions","text":"<p>You can call static methods from <code>Character</code> class as if they were instance methods, even on primitive <code>char</code> values.</p> <pre><code>println(`c`.isLowerCase()) // true\n\nCharacter foo = `s`\nprintln(foo.isDigit()) // false\n</code></pre>"},{"location":"guides/stdlib-extensions/#charsequence-extensions","title":"CharSequence Extensions","text":"<p>There are some extensions on classes implementing <code>CharSequence</code> to handle them like a collection of characters.</p> <pre><code>CharSequence foo = \"a simple string 2\"\nprintln(foo[0])\nList&lt;char&gt; charList = foo.toList()\n\nint index = foo.indexOf { it == ` ` }\nint lastIndex = foo.lastIndexOf { it == `s` }\n\nif (Character c = foo.find { it.isDigit() }) {\n  println(\"There is a digit char: '$c'\")\n}\nprintln(\"There are \" + foo.count { it == `s` } + \" 's'\")\nif (foo.any { it.isWhitespace() }) {\n  println(\"The string contains spaces\")\n}\n</code></pre> <p>And other useful methods</p> <pre><code>CharSequence foo = \"string\"\nprintln(foo.reversed())\n\nprintln(\"123\".toInt()) // there is also toDouble, toFloat, toLong\n</code></pre>"},{"location":"guides/stdlib-extensions/#other-extensions","title":"Other extensions","text":"<p>There are other extensions in Marcel's Standrard Library you can use, by explicitely importing them. E.g.</p> <pre><code>import extension marcel.lang.extensions.TimeExtensions\n</code></pre>"},{"location":"guides/stdlib-extensions/#time-extensions","title":"Time Extensions","text":"<p>The TimeExtensions class provides utilities to construct durations easily.</p> <p>Let's take a look at the below example</p> <pre><code>import extension marcel.lang.extensions.TimeExtensions\n\nprintln(1.days)\nprintln(2.hours)\nprintln(1.minutes)\nprintln(1.seconds)\nprintln(1.millis)\nprintln(1.nanos)\n</code></pre> <p>You can access a \"field\" from the <code>int</code>, <code>Integer</code>, <code>long</code>, <code>Long</code> classes to create a duration. Of course this isn't a real field, as primitive types don't have any, but an extension provided by the <code>TimeExtensions</code> class.</p>"},{"location":"guides/yaml/","title":"Parsing and producing YAML","text":"<p>Marcel comes with integrated support for converting between Marcel objects and YAML. The classes dedicated to YAML serialization and parsing are found in the <code>marcel.yaml</code> package.</p> <p>The YAML (de)serialization is backed by Jackson.</p> <p>All is handled by the <code>DynamicYaml</code> class. It takes advantage of Dynamic Objects to make this API easy to use.</p> <pre><code>import marcel.yaml.*\n\n\ndynobj yaml = DynamicYaml.instance.read('{\"id\": 0, \"name\": \"Something\", \"tags\": [\"fun\", \"adventure\", \"friendship\"], \"metadata\": {\"foo\": \"bar\"}}')\nprintln(yaml['name'] == yaml.name) // true\nprintln(yaml.tags[2]) // friendship\nprintln(yaml.metadata.foo) // bar\nprintln(yaml.id.asInt() + 1) // 1\n\nyaml.name = \"Something Else\"\n\nprintln(DynamicYaml.instance.writeAsString(yaml))\nDynamicYaml.instance.write([yaml], new File('output.yaml')) // write yaml list in file\n</code></pre>"},{"location":"language-specification/","title":"Language Specification","text":"<p>In this section, you'll learn all the little secrets of MarcelLang.</p>"},{"location":"language-specification/basics/","title":"Basics","text":""},{"location":"language-specification/basics/#identifiers","title":"Identifiers","text":"<p>An identifier is a name that you can use to define a class, field, a function or variable.</p> <p>An identifier must follows all the below rules</p> <ul> <li>it must start with a letter ('a' to 'z' , and 'A' to 'Z'), or an underscore</li> <li>the following characters can be a letter, an underscore or a number</li> </ul>"},{"location":"language-specification/basics/#class-identifiers","title":"Class identifiers","text":"<p>To reference a class, you need tp add the <code>.class</code> suffix, like in Java. But note that you can only reference simple name of classes, this means that you need to import it first.</p> <pre><code>import java.util.concurrent.Callable\nprintln(Callable.class)\n\nprintln(Object.class)\n</code></pre>"},{"location":"language-specification/basics/#comments","title":"Comments","text":"<p>You can comment your code in Marcel the same way you would in Java.</p> <p>Define comments like you would in Java. <code>// ...</code> for a single line comment, and <code>/* ... */</code> for a multi-line comment</p> <pre><code>// this function does stuff\ndoStuff()\n\n/* this function\n  does some\n  other stuff\n */\ndoOtherStuff()\n</code></pre>"},{"location":"language-specification/basics/#keywords","title":"Keywords","text":"<p>Marcel has the following keywords, which you cannot use as variable/function/fields names</p> <ul> <li>async</li> <li>int</li> <li>dynobj</li> <li>do</li> <li>long</li> <li>short</li> <li>float</li> <li>double</li> <li>bool</li> <li>byte</li> <li>void</li> <li>char</li> <li>fun</li> <li>return</li> <li>true</li> <li>false</li> <li>new</li> <li>import</li> <li>as</li> <li>inline</li> <li>static</li> <li>for</li> <li>in</li> <li>if</li> <li>else</li> <li>null</li> <li>break</li> <li>continue</li> <li>def</li> <li>class</li> <li>extension</li> <li>package</li> <li>extends</li> <li>implements</li> <li>final</li> <li>switch</li> <li>when</li> <li>this</li> <li>super</li> <li>dumbbell</li> <li>try</li> <li>catch</li> <li>finally</li> <li>instanceof</li> <li>throw</li> <li>throws</li> <li>constructor</li> <li>public</li> <li>protected</li> <li>internal</li> <li>private</li> <li>while</li> </ul>"},{"location":"language-specification/extension-classes/","title":"Extension classes","text":"<p>Extension classes allows you to add methods to an existing class.</p>"},{"location":"language-specification/extension-classes/#how-to-declare","title":"How to declare","text":"<p>An extension class is declared like a regular class, but with the keyword <code>extension</code>. You'll also need to specify which class your are extending.</p> <pre><code>extension class MyExtension for Integer {\n}\n</code></pre>"},{"location":"language-specification/extension-classes/#define-instance-methods","title":"Define instance methods","text":"<p>Define methods as you would if you were in the class you are extending (not talking about inheritance).</p> <pre><code>extension class MyExtension for Integer {\n\n  fun int next() {\n    return this + 1\n  }\n\n  fun float foo() {\n    return floatValue() + 2f * next()\n  }\n\n}\n</code></pre> <p>As you can see in the above example, you can also call methods of the extended class, and other extensions methods  you defined.</p>"},{"location":"language-specification/extension-classes/#define-static-methods","title":"Define static methods","text":"<p>This works the same as instance methods. Define your static method as if you were in the extended class.</p> <pre><code>extension class MyExtension for Integer {\n\n  static fun int zoo() {\n    return 1\n  }\n\n}\n</code></pre>"},{"location":"language-specification/extension-classes/#how-to-use","title":"How to use","text":"<p>Import your extension class with the <code>extension</code> keyword.</p> <pre><code>// another file\nimport extension MyExtension\n\nInteger a = 1\nprintln(a.next())\nprintln(Integer.zoo())\n</code></pre> <p>Note that you can also use an extension in the same file it was declared in. In such case, you don't need to specify the import</p> <pre><code>extension class MyExtension for Integer {\n   fun int next() {\n      return this + 1\n    }\n\n    fun float foo() {\n      return floatValue() + 2f * next()\n    }\n\n   static fun int zoo() {\n      return 1\n    }\n}\n\nInteger a = 1\nprintln(a.next())\nprintln(Integer.zoo())\n</code></pre>"},{"location":"language-specification/lambdas/","title":"Lambdas","text":"<p>Marcel supports lambda expressions, but note that they are not compiled to Java lambdas, they are compiled to anonymous classes instead.</p> <p>Lambda are declared like Kotlin's, and Groovy closures. They can be used for any functional interfaces, such as Runnable, Supplier...</p>"},{"location":"language-specification/lambdas/#lambdas-with-no-parameters","title":"Lambdas with no parameters","text":"<pre><code>Lambda0 l0 = {\n\n}\n</code></pre>"},{"location":"language-specification/lambdas/#lambdas-with-1-parameter","title":"Lambdas with 1 parameter","text":"<p>If you don't specify any parameter, an implicit <code>Object it</code> parameter will be declared.</p> <pre><code>Lambda0 l1 = {\n  println(it)\n}\n</code></pre> <p>Or you can explicitly declare it yourself, specifying the type</p> <pre><code>Lambda1 l1 = { Integer p0 -&gt;\n  println(p0)\n}\n</code></pre>"},{"location":"language-specification/lambdas/#lambdas-with-2-parameter","title":"Lambdas with 2+ parameter","text":"<p>You have to declare explicitly all parameters, separated by a comma</p> <pre><code>Lambda3 l3 = { Integer foo, Long bar, String zoo -&gt;\n  // do something\n}\n</code></pre>"},{"location":"language-specification/variables/","title":"Variables","text":""},{"location":"language-specification/variables/#declare-variables","title":"Declare variables","text":"<p>Marcel variable declarations are the same as Java's</p> <pre><code>int a = 2\nObject o = new Object()\n\nList&lt;int&gt; l = [1, 2] // collection of primivites\n</code></pre>"},{"location":"language-specification/variables/#multiple-declarations","title":"Multiple declarations","text":"<p>Marcel supports multiple assignments in one statement</p> <pre><code>def (int a, String b, Object c) = [1, \"2\", new Object()]\n\ndef (int d, String e, Object f) = functionReturningAnArrayOrList()\n</code></pre> <p>Note that if the array/list is shorter than the number of variable declared, this will lead to a runtime error</p> <p></p> <p>Sometimes you might want to ignore a specific item of a list, You can use the <code>_</code> identifier to let the compiler know that.</p> <p>E.g.</p> <pre><code>def (_, String world) = (\"hello world\" =~ /hello (world)/).groups()\n</code></pre>"},{"location":"language-specification/variables/#variable-assignments","title":"Variable assignments","text":"<p>Just use <code>=</code> to assign values to defined variables</p> <pre><code>int a = 2\n\na = 3\n</code></pre>"},{"location":"language-specification/variables/#properties","title":"Properties","text":"<p>Marcel allows to access getters and setters as properties.</p> <p>Suppose you have the below class</p> <pre><code>class Foo {\n  private int bar\n\n  fun getBar() {\n    return this.@bar\n  }\n\n  fun setBar(int bar) {\n    this.@bar = bar\n  }\n}\n</code></pre> <p>You could call these <code>getBar/setBar</code> methods using the property syntax. The <code>@bar</code> notation is the direct field access operator, make sure to reference the Java class's field.</p> <pre><code>Foo foo = new Foo()\n\nfoo.bar = 5 // will actully call foo.setBar(5)\nprintln(foo.bar) // will actually call foo.getBar()\n\n</code></pre>"},{"location":"language-specification/variables/#automatic-casting","title":"Automatic casting","text":"<p>Variable assignments are automatically casted when needed.</p> <pre><code>Optional o = Optional.of(123)\nInteger myInteger = o.get() // returns Object cast into an Integer \nint myInt = o.get() // returns Object cast into an Integer then into an int\n</code></pre> <p>This can be useful as Marcel doesn't support generic types.</p>"},{"location":"language-specification/control-flows/exception-handling/","title":"Exception Handling","text":""},{"location":"language-specification/control-flows/exception-handling/#throw-exception","title":"Throw Exception","text":"<p>In Marcel you can throw Exceptions (or any Throwable) like in Java</p> <pre><code>throw new RuntimeException(\"Error Message\")\n</code></pre> <p>You are not forced to catch checked Exceptions in Marcel.</p>"},{"location":"language-specification/control-flows/exception-handling/#trycatchfinally","title":"Try/Catch/Finally","text":"<p>Exception handling is very similar as Java's.</p> <pre><code>try {\n  Object a = null\n  println(a.hashCode())\n  println(\"Successfully tried\")\n} catch (IOException|NullPointerException e) {\n    println(\"Caught exception\")\n} finally {\n  println(\"finally\")\n}\n</code></pre> <p>The above code will print</p> <pre><code>Caught exception\nFinally\n</code></pre>"},{"location":"language-specification/control-flows/exception-handling/#try-with-resources","title":"Try with resources","text":"<p>Try with resources is like in Java. You can declare Variables as resources and they will be properly closed automatically by the compiler.</p> <pre><code>try (BufferedReader reader = Files.reader('input.txt')) {\n  println(reader.readLine())\n} catch (IOException e) {\n  e.printStackTrace()\n}\n</code></pre>"},{"location":"language-specification/control-flows/for-loops/","title":"For loops","text":"<p>There are different ways to iterate over elements</p>"},{"location":"language-specification/control-flows/for-loops/#for-i","title":"For i","text":"<p>The Java for i is compatible with Marcel</p> <pre><code>for (int i = 0; i &lt; 10; i++) {\n  println(i)\n}\n</code></pre>"},{"location":"language-specification/control-flows/for-loops/#for-in","title":"For in","text":"<p>The <code>in</code> keyword allows to iterate over values in an array, any objects implementing Iterable (including all Collections) or Iterator.</p> <pre><code>int[] ints = getInts()\nfor (int i in ints) {\n  println(i)\n}\n</code></pre> <p>Marcel also have a Ranges, allowing you to iterate with the below syntax</p> <pre><code>// inclusive range\nfor (int i in 0..9) {\n  println(i)\n}\n\n// exclusive range\nfor (int i in 0..&lt;10) {\n  println(i)\n}\n\n// also work in reverse orde\nfor (int i in 9..0) {\n  println(i)\n}\n\n// exclusive range\nfor (int i in 10&gt;..0) {\n  println(i)\n}\n</code></pre>"},{"location":"language-specification/control-flows/for-loops/#for-in-map","title":"For in map","text":"<p>You can also iterate over a Map entries using the below syntax</p> <pre><code>Map m = [foo: 1, bar: 2]\nfor ((String key, int value) in m) println(\"$key=$value\")\n</code></pre>"},{"location":"language-specification/control-flows/if-else/","title":"If expression","text":"<p>If statements are similar as Java's, but you can provide any expression in them. If the provided expression is not a boolean, the Marcel truth will decide if your expression is <code>true</code> or not.</p> <pre><code>if (a == 1) {\n  println(\"a is 1\")\n} else if (a == 2) {\n  println(\"a is 2\")\n} else {\n  println(\"a is not 1 and not 2\")\n}\n</code></pre>"},{"location":"language-specification/control-flows/if-else/#if-variable-declaration","title":"if variable declaration","text":"<p>The marcel truth allows you to declare variable in an <code>if</code> condition, and execute the code block if the variable is truthy</p> <pre><code>if (Something result = fetchSomething()) {\n  println(\"Fetched $result\")\n}\n</code></pre> <p>You can also unbox Optional values such as in the below example</p> <pre><code>// assuming getOptionalInteger() returns an Optional\nif (Integer result = getOptionalInteger()) {\n  println(result)\n}\n</code></pre>"},{"location":"language-specification/control-flows/marcel-truth/","title":"Marcel truth","text":"<p>A truthy value is a value that is considered to be true for an if, or a while. </p> <p>A falsey value is a value that is considered false in those places.</p> <p>The only falsey values are the following: - <code>false</code> - <code>null</code> - a Boolean instance whose value is <code>false</code> - <code>Optional.empty()</code>, <code>OptionalInt.empty()</code>, <code>OptionalDouble.empty()</code>, <code>OptionalLong.empty()</code> - An empty collection - An empty array - An empty Map - An empty String - A Matcher who's <code>find()</code> method would return false - A File who's <code>exists()</code> method would return false - A failure Result - An object implementing MarcelTruth who's <code>isTruthy()</code> method would return false</p> <p>Any other value is truthy.</p>"},{"location":"language-specification/control-flows/switch-when/","title":"Switch and When","text":"<p>Marcel defines conditional control flows that can return values. Note that in the below control flows described, you can't re-assign a value to local variables created outside  the switch/when scope.</p>"},{"location":"language-specification/control-flows/switch-when/#when","title":"When","text":"<pre><code>when {\n  string == \"foo\" -&gt; 2\n  string == \"bar\" -&gt; {\n    doSomeStuff()\n    3\n  }\n  otherCondition() -&gt; 4\n}\n</code></pre> <p>Each <code>when</code> branch consists of a condition, and a statement. If the given condition is true, the corresponding statement will be executed.</p> <p>Whens are very similar to <code>if/elseif/else</code> control flow, but they allow you to return values.  They are useful to assign variables, or returning values in functions.</p> <p>In the above example, you can notice that a default case is missing. If no conditions matched, the <code>when</code> will return <code>null</code>.</p> <p>This means that you must always specify an <code>else</code> branch for whens returning primitive types, as they cannot be null.</p> <pre><code>int myInt = when {\n  string == \"foo\" -&gt; 2\n  string == \"bar\" -&gt; {\n    doSomeStuff()\n    3\n  }\n  string == someString() -&gt; 4\n  otherCondition() -&gt; 5\n  else -&gt; 5\n}\n</code></pre>"},{"location":"language-specification/control-flows/switch-when/#switch","title":"Switch","text":"<p>Switch are very similar to whens. Every switch can be translated to a when (but the other way around is not true).</p> <p>In switches, you compare an expression against multiple values. Based on the above <code>when</code> example, we could do the following <code>switch</code></p> <pre><code>switch (string) {\n  \"foo\" -&gt; 2\n  \"bar\" -&gt; {\n    doSomeStuff()\n    3\n  }\n  someString() -&gt; 4\n}\n</code></pre> <p>You'll notice that we couldn't translate the <code>when</code> condition <code>otherCondition()</code>, this is because it isn't a comparison against the switched expression.</p> <p>Each switch branch consists of a value, and a statement. If the provided switch expression matches the branch's expression,  the corresponding statement will be executed.</p> <p>Switches also have an else, that is required when returning a primitive</p> <pre><code>int myInt = switch (string) {\n  \"foo\" -&gt; 2\n  \"bar\" -&gt; {\n    doSomeStuff()\n    3\n  }\n  someString() -&gt; 4\n  else -&gt; 5\n}\n</code></pre>"},{"location":"language-specification/control-flows/switch-when/#access-the-switched-expression","title":"Access the switched expression","text":"<p>The provided expression can be accessed in the switch branches using the implicit variable <code>it</code>.</p> <pre><code>int myInt = switch (computeSomeInt()) {\n  1 -&gt; it + 1\n  else -&gt;  it + 4\n}\n</code></pre>"},{"location":"language-specification/control-flows/while-loops/","title":"While loops","text":"<p>While loops are also similar as Java's. You can also provide any expression in them as you would in a Marcel if. If the provided expression is not a boolean, the Marcel truth will decide if your expression is <code>true</code> or not.</p> <pre><code>int i = 0\nwhile (i &lt; 10) {\n  println(i++)\n}\n</code></pre>"},{"location":"language-specification/control-flows/while-loops/#while-variable-declaration","title":"while variable declaration","text":"<p>The marcel truth allows you to declare variable in an <code>while</code> condition, and execute the code block if the variable is truthy</p> <pre><code>while (String line = reader.readLine()) println(line)\n\n// outside the loop, this line variable doesn't exist anymore\n</code></pre>"},{"location":"language-specification/control-flows/while-loops/#do-while","title":"Do while","text":"<p>You can also perform do-while instructions, which will always execute at least one the do statement and then check the condition. If the condition is true the do statement is executed again.</p> <pre><code>int i = 15\ndo {\n  println(i++)\n} while (i &lt; 10)\n</code></pre> <p>The above code will only print <code>15</code>.</p>"},{"location":"language-specification/control-flows/while-loops/#do","title":"Do","text":"<p>You can specify a <code>do</code> instruction without a while instruction at the end. It will just execute the do statement once. This can be useful to create inner scopes, in which you can create all the local variables you want, as they won't be accessible outside the <code>do</code> scope</p> <pre><code>\nint result = 5\ndo {\n  int variable = 1\n  int anotherVariable = 2\n  int anotherOtherVariable = 3\n  int anotherOne = 5\n  result = variable + anotherVariable + anotherOtherVariable + anotherOne\n}\n\n// now only result variable exists\n</code></pre>"},{"location":"language-specification/iterable-operations/","title":"Iterable Operations","text":"<p>Iterable operations provide a special syntax to perform common operations of a daily programmer's life on Iterables.</p> <p>Actually, those operations work with Iterables, and also with arrays and CharSequence (e.g. String).</p>"},{"location":"language-specification/iterable-operations/any-all/","title":"Any, All","text":"<p>Checking if any/all elements of an Iterable, CharSequence or array all matches a given predicates is possible using the below syntax.</p>"},{"location":"language-specification/iterable-operations/any-all/#any","title":"Any","text":"<pre><code>List&lt;int&gt; list = [1, 2, 3, 4]\nprintln(when int a in list |&gt; a &gt;= 3) // true\n</code></pre> <p>The <code>|&gt;</code> arrow is used to check if at least one element matches the predicate.</p>"},{"location":"language-specification/iterable-operations/any-all/#all","title":"All","text":"<pre><code>List&lt;int&gt; list = [1, 2, 3, 4]\nprintln(when int a in list &amp;&gt; a &gt;= 3) // false\n</code></pre> <p>The <code>&amp;&gt;</code> arrow is used to check if all elements matches the predicate.</p>"},{"location":"language-specification/iterable-operations/any-all/#negations","title":"Negations","text":"<p>You can also negate those conditions using the <code>!when</code> keyword.</p> <pre><code>println(!when int a in list |&gt; a &gt;= 3) // false\nprintln(!when int a in list &amp;&gt; a &gt;= 3) // true\n</code></pre>"},{"location":"language-specification/iterable-operations/any-all/#complex-boolean-expressions","title":"Complex boolean expressions","text":"<p>To use properly the above described operations in boolean expressions, wrap them with the parenthesis to avoid any ambiguity</p> <pre><code>if ((when int a in list &amp;&gt; a &gt;= 3) &amp;&amp; somethingElse) {\n  doAllTheThings()\n}\n</code></pre>"},{"location":"language-specification/iterable-operations/chain-operations/","title":"Chain operations","text":"<p>You can chain multiple iterable operations in a same expression using the right shift (<code>&gt;&gt;</code>) operator.</p> <pre><code>List&lt;int&gt; list = [1, 2, 3, 4]\nprintln(list &gt;&gt; when int a -&gt; a % 2 == 0)\nprintln([for int a in list -&gt; a + 3] &gt;&gt; when int a -&gt; a % 2 == 0)\n</code></pre> <p>In those example you can see that we omit the <code>in something</code> part of the operations, this is because the left operand of the <code>&gt;&gt;</code> operator is used instead.</p> <p>So the above code is equivalent of the below code.</p> <pre><code>List&lt;int&gt; list = [1, 2, 3, 4]\nprintln(when int a in list -&gt; a % 2 == 0)\nprintln(when int a in [for int a in list -&gt; a + 3] -&gt; a % 2 == 0)\n</code></pre> <p>But this piece of code is hard to read, right? That is why the <code>&gt;&gt;</code> is here. </p>"},{"location":"language-specification/iterable-operations/find/","title":"Find","text":"<p>This iterable operation allows to find an element on an Iterable, CharSequence or array and return it, or null. As the element may not be found, this operator always return an object, even for collections of primitive (e.g. Integer for a <code>List&lt;int&gt;</code>).</p> <pre><code>List&lt;int&gt; list = [1, 2, 3, 4]\nprintln(when int a in list -&gt; a % 2 == 0) // 2\nprintln(when int a in list -&gt; a % 2 == 5) // null\n</code></pre>"},{"location":"language-specification/iterable-operations/map-filter/","title":"Map and/or Filter","text":""},{"location":"language-specification/iterable-operations/map-filter/#map","title":"Map","text":"<p>You can create a new collection resulting of the mapping of another.</p> <pre><code>List&lt;int&gt; list = [1, 2, 3, 4]\nList&lt;int&gt; list2 = [for int i in list -&gt; i + 1] // [2, 3, 4, 5]\n</code></pre>"},{"location":"language-specification/iterable-operations/map-filter/#filter","title":"Filter","text":"<p>Filtering is also possible using a similar syntax.</p> <pre><code>List&lt;int&gt; list = [1, 2, 3, 4]\nList&lt;int&gt; list2 = [for int i in list if i &lt;= 2] // [1, 2]\n</code></pre>"},{"location":"language-specification/iterable-operations/map-filter/#map-and-filter","title":"Map and Filter","text":"<p>You can do both in one operation.</p> <pre><code>List&lt;int&gt; list = [1, 2, 3, 4]\nList&lt;float&gt; list2 = [for int i in list -&gt; i + 0.1f if i &lt;= 2] // [1.1f, 2.2f]\n</code></pre>"},{"location":"language-specification/iterable-operations/map-filter/#casting","title":"Casting","text":"<p>All the above operations can return Lists, primitive Lists, Sets, or primitive Sets. The type is usually guessed by the compiler when possible (e.g. looking at the type of the variable you're trying to set), but you can explicitly specify the wanted type using the as operator.</p> <pre><code>List&lt;int&gt; list = [1, 2, 3, 4]\nSet&lt;int&gt; list2 = [for int i in list -&gt; i % 2] // [0, 1]\nprintln([for int i in list -&gt; Optional.of(i % 2)] as Set) // [Optional(0), Optional(1)]\n</code></pre>"},{"location":"language-specification/operators/","title":"Operators","text":"<p>Marcel provides arithmetic operators to work with numbers (+, -, /, * and soonish %) but there are also operators that can be used on specific types.</p> <p>We will explore all of them in this section</p>"},{"location":"language-specification/operators/as/","title":"As (smart casting)","text":"<p>The <code>as</code> keyword allows to smart cast variables to a provided type.</p>"},{"location":"language-specification/operators/as/#smart-casting","title":"Smart casting","text":"<p>Smart casting is like an enhanced Java cast. It can cast objects like a Java cast would, but it can also convert the object to make it fit the target type.</p>"},{"location":"language-specification/operators/as/#collections-smart-casting","title":"Collections smart casting","text":"<p>The smart cast can transform arrays into (primitive) lists/sets </p> <pre><code>int[] array = [1, 2, 3]\n\nList&lt;int&gt; intList = array as List&lt;int&gt;\nSet&lt;long&gt; longSet = [1l, 2l, 3l] as Set&lt;long&gt;\n</code></pre>"},{"location":"language-specification/operators/as/#boolean-truthy-smart-casting","title":"Boolean (truthy) smart casting","text":"<p>You can smart cast any value to a boolean. The value of the boolean will be determined based on the Marcel truth.</p>"},{"location":"language-specification/operators/as/#dynamic-object-smart-casting","title":"Dynamic object smart casting","text":"<p>Any type can become a dynamic object</p> <pre><code>dynobj obj = 1 as dynobj\n</code></pre>"},{"location":"language-specification/operators/as/#java-casting","title":"(Java) casting","text":"<p>To perform a simple cast, you can use the function <code>cast</code> with the diamond operator,  provided specifically for this use-case</p> <pre><code>int a = 1\n\nInteger b = a as Integer\nNumber c = b as Number\nLong d = c as Long // will fail as a is not an instance of Long\n</code></pre>"},{"location":"language-specification/operators/comparison/","title":"Comparison Operators","text":""},{"location":"language-specification/operators/comparison/#equal","title":"Equal (==)","text":"<p>Unlike in Java <code>==</code> operator will do its best to compare the 2 operands by value. This operator is null safe, meaning that if one of the operand is null, it won't throw a <code>NullPointerException</code>.</p> <p>This operator works as described below - if both operand are primitives, Java-like <code>==</code> will be performed - if both operand are primitive arrays, Arrays.equals() will be used to compare the values - if both operand are object arrays, Objects.deepEquals() will be used to compare the values - otherwise it will call Objects.equals()</p> <p>This logic is applied at compile-time, meaning you won't have a runtime overhead because the program would have to check types. - if at least one of the two operand is an Object, the other operand is casted as an object if needed and the Marcel <code>==</code> is applied.</p>"},{"location":"language-specification/operators/comparison/#not-equal","title":"Not Equal (!=)","text":"<p>The not equal is the negation of the Marcel's <code>==</code></p>"},{"location":"language-specification/operators/comparison/#lt-loe-gt-goe","title":"LT, LOE, GT, GOE (&lt;, &lt;= ,&gt;, &gt;=)","text":"<p>These operators works like in Java for primitive types. For object types, Marcel will check at compile-time if the first operand has a <code>compareTo()</code> method and apply it on the second operand. The result of the compareTo will be used to apply the given comparison.</p>"},{"location":"language-specification/operators/comparison/#is-same","title":"Is Same (===)","text":"<p>This operator is the Java's <code>==</code> operator for Objects. It will check if the two operand are the same instance, or are both null. (Note that it can't be used on primitives).</p>"},{"location":"language-specification/operators/comparison/#is-not-same","title":"Is Not Same (!==)","text":"<p>It is the negation of the Is Same operator.</p>"},{"location":"language-specification/operators/direct-field-access/","title":"Direct field access @fieldName","text":"<p>This operator allows to make sure to reference a class field, and not a getter/setter.</p> <p>E.g.</p> <pre><code>class Foo {\n int bar\n\n  fun getBar() {\n    return this.@bar\n  }\n\n  fun setBar(int bar) {\n    this.@bar = bar\n  }\n}\n\nFoo foo = new Foo()\n</code></pre> <p>In the above class, calling <code>foo.@bar</code> or <code>foo.@bar = 4</code> would make sure to actually use the field, and not the getter/setter.</p>"},{"location":"language-specification/operators/indexed-access/","title":"Indexed Access Operator (expr[index])","text":"<p>This operator is usually (or at least in Java) reserved for arrays,  but in Marcel you can also use it to access lists. You can get/set  items of your list using the same syntax as for an array</p> <pre><code>\nList&lt;int&gt; list = [1, 2, 3]\n\nprintln(list[0])\n\nlist[1] = 4\n</code></pre> <p></p> <p>You can also define your own accesses for custom types</p>"},{"location":"language-specification/operators/indexed-access/#safe-indexed-access-getatsafe","title":"Safe indexed access (getAtSafe)","text":"<p>Similarly to safe navigation, you can access elements of list/arrays</p> <pre><code>println(list?[5]) // will print null\n</code></pre> <p>This operator checks that the index provided is within the list/array's bounds (<code>0 &lt;= index &lt; length</code>)</p> <p>You can also set elements safely with the <code>putAtSafe</code> operator</p> <pre><code>List&lt;int&gt; = [1, 2, 3]\n\nlist?[1] = 5 // will actually set the value\nlist?[10] = 4 // will not set the value as the index is not within bounds\n</code></pre>"},{"location":"language-specification/operators/instanceof/","title":"Instance Of (type checking)","text":"<p>The <code>instanceof</code> keyword allows to verify if an Object variable is an instance of the provided type.</p> <p>It cannot be used on primitive variables, and will always return <code>false</code> on <code>null</code> variables.</p>"},{"location":"language-specification/operators/instanceof/#examples","title":"Examples","text":"<pre><code>Integer a = 1\n\nprintln(a instanceof Integer) // true\nprintln(a instanceof Number) // true\nprintln(a instanceof Long) // false\n</code></pre>"},{"location":"language-specification/operators/instanceof/#not-instance-of","title":"Not Instance Of","text":"<p>To check the opposite, use <code>!instanceof</code></p> <pre><code>Integer a = 1\n\nprintln(a !instanceof Integer) // false\nprintln(a !instanceof Number) // false\nprintln(a !instanceof Long) // true\n</code></pre>"},{"location":"language-specification/operators/left-shift/","title":"Left Shift operator (&lt;&lt;)","text":"<p>Left shift operator allows to add elements to collections</p> <pre><code>List&lt;int&gt; a = [1, 2, 3]\n\na &lt;&lt; 2\n</code></pre>"},{"location":"language-specification/operators/minus/","title":"Minus operator (-)","text":"<p>The minus operator is used for arithmetic but in Marcel it also has other uses.</p>"},{"location":"language-specification/operators/minus/#add-collections","title":"Add collections","text":"<p>You can use <code>-</code> to add Collections. The two operand will not be modified. A new collection will be created with the elements  of the first operand having removed all elements from the second operand if any.</p> <p>It works well with lists</p> <pre><code>\nList&lt;int&gt; myList1 = [1, 2, 3]\nList&lt;int&gt; myList2 = [3, 4, 5]\n\nList&lt;int&gt; myList3 = mySet1 - mySet2\nprintln(myList3) // [1, 2]\n</code></pre> <p>and sets</p> <pre><code>\nSet&lt;int&gt; mySet1 = [1, 2, 3]\nSet&lt;int&gt; mySet2 = [3, 4, 5]\n\nSet&lt;int&gt; mySetUnion = mySet1 - mySet2\nprintln(mySetUnion) // [1, 2]\n</code></pre> <p></p> <p>You can also add different kind of collections. The type of the returned collection will be the same as the first operand</p> <pre><code>Set&lt;int&gt; newSet = mySet1 - myList1\nList&lt;int&gt; newList = myList1 - mySet1\n</code></pre>"},{"location":"language-specification/operators/operator-overloading/","title":"Define custom operators","text":"<p>You can define operators in a very similar way as groovy's.</p> <p>Each operator is associated to a function. To define an operator for a given type.</p> <p>Here is the table of functions to define for each operator</p>"},{"location":"language-specification/operators/operator-overloading/#define-operators-from-extensions","title":"Define operators from extensions","text":"Operator Method a + b a.plus(b) a - b a.minus(b) - a a.negate() a * b a.multiply(b) a % b a.mod(b) a / b a.div(b) a &lt;&lt; b a.leftShift(b) a &gt;&gt; b a.rightShift(b) a[b] a.getAt(b) a?[b] a.getAtSafe(b) a[b, c, d] a.getAt(b, c, d) a[b] = c a.putAt(b, c) a?[b] = c a.putAtSafe(b, c)"},{"location":"language-specification/operators/plus/","title":"Plus operator (+)","text":"<p>The plus operator is used for arithmetic and concatenating Strings, but in Marcel it also has other uses.</p>"},{"location":"language-specification/operators/plus/#add-collections","title":"Add collections","text":"<p>You can use <code>+</code> to add Collections. The two operand will not be modified. A new collection will be created with both operand added to it.</p> <p>It works well with lists</p> <pre><code>\nList&lt;int&gt; myList1 = [1, 2, 3]\nList&lt;int&gt; myList2 = [4, 5, 6]\n\nList&lt;int&gt; myList3 = mySet1 + mySet2\nprintln(myList3) // [1, 2, 3, 4, 5, 6]\n</code></pre> <p>and sets</p> <pre><code>\nSet&lt;int&gt; mySet1 = [1, 2, 3]\nSet&lt;int&gt; mySet2 = [3, 4, 5]\n\nSet&lt;int&gt; mySetUnion = mySet1 + mySet2\nmySetUnion(myList3) // [1, 2, 3, 4, 5]\n</code></pre> <p></p> <p>You can also add different kind of collections. The type of the returned collection will be the same as the first operand</p> <pre><code>Set&lt;int&gt; newSet = mySet1 + myList1\nList&lt;int&gt; newList = myList1 + mySet1\n</code></pre>"},{"location":"language-specification/operators/safe-navigation/","title":"Safe Navigation Operator (?.)","text":"<p>The safe navigation operator is used to access a property of an object that might be null, without getting a <code>NullPointerException</code>.</p> <p>It is a simple syntax allowing you to simple code. In Java, you could code</p> <pre><code>Foo foo = getFoo()\nBar bar = foo != null ? foo.getBar() : null\n</code></pre> <p>In Marcel, you would code</p> <pre><code>Foo foo = getFoo()\nBar bar = foo?.bar // Marcel recognizes getters and translates '.bar' into '.getBar()' at compilation\n</code></pre>"},{"location":"language-specification/operators/ternary-elvis/","title":"Ternary operator ( ?  : ) <p>Marcel supports ternary operator like in Java. This operator have 3 operands: 1. the condition expression 2. the 'true' expression 3. the 'false' expression.</p> <p>This operator evaluates the condition. It can be any kind of expression, as the Marcel truth will determine if the expression is truthy or not, for non-boolean expressions.</p> <p>If the condition expression is truthy, the 'true' expression will be evaluated, otherwise it will be the 'false' expression.</p> <p>E.g.</p> <pre><code>int temperature = isSunny() ? 21 : -5\nprintln(temperature)\n\nfun bool isSunny() -&gt; return true\n</code></pre> <p>This script will print the value <code>21</code></p> <p>Let's take a look at another example.</p> <pre><code>Integer input = null\nInteger a = input ? input : 34\nprintln(a)\n</code></pre> <p>This script will print the value <code>34</code></p> <p>Note that this last example can be simplified using the Elvis operator</p>","text":""},{"location":"language-specification/operators/ternary-elvis/#elvis-operator","title":"Elvis operator","text":"<p>The Elvis operator is just a simplified ternary operator in which the condition expression and the 'true' expression are the same.</p> <p>You could translate the above example using the below code</p> <pre><code>Integer input = null\nInteger a = input ?: 34\nprintln(a)\n</code></pre>"},{"location":"language-specification/source-file-structure/","title":"Program structure","text":""},{"location":"language-specification/source-file-structure/#package","title":"Package","text":"<p>A Marcel source file can have a package. It is optional but if it is specified, it must be the first instruction in the file (excluding comments)</p> <pre><code>package my.package\n</code></pre>"},{"location":"language-specification/source-file-structure/#imports","title":"Imports","text":"<p>Then, some imports can follow. You can consult the default imported class/package here</p>"},{"location":"language-specification/source-file-structure/#class","title":"Class","text":"<p>You can define classes like in Java. </p>"},{"location":"language-specification/source-file-structure/#functions","title":"Functions","text":"<p>Classes can have functions</p>"},{"location":"language-specification/source-file-structure/#fields","title":"Fields","text":"<p>Classes can also have fields</p>"},{"location":"language-specification/source-file-structure/annotations/","title":"Annotations","text":"<p>Annotations are a lot like Java's. Use the <code>@MyAnnotation</code> syntax to annotate a class, field or method parameter.</p> <pre><code>@MyAnnotation\nclass MyClass {\n  @MyAnnotation\n  int myField\n\n  fun int myMethod(@MyAnnotation Integer someInt) {\n    return someInt + myField\n  }\n}\n</code></pre>"},{"location":"language-specification/source-file-structure/annotations/#annotation-attributes","title":"Annotation attributes","text":"<p>You can specify attributes like in Java. If your annotation only has one attribute, with the name <code>value()</code> You can just  type your attribute value between parentheses.</p> <pre><code>@MyAnnotation(1)\n</code></pre> <p>Or you can specify the attribute name like in the below example</p> <pre><code>@MyAnnotation(value = 1)\n</code></pre> <p>If you have multiple attributes, separate them with a comma</p> <pre><code>@MyAnnotation(value1 = 1, value2 = 3)\n</code></pre>"},{"location":"language-specification/source-file-structure/annotations/#enum-attributes","title":"Enum attributes","text":"<p>When specifying enum attributes you just have to specify the enum's name, without its class</p> <pre><code>@MyAnnotation(timeUnit = MILLISECONDS)\n</code></pre>"},{"location":"language-specification/source-file-structure/annotations/#class-attributes","title":"Class attributes","text":"<p>For attributes of type <code>Class</code>, you can specify any class as you would in Java</p> <pre><code>@MyAnnotation(converter = MyConverter.class)\n</code></pre> <p>But like in Groovy, you can also specify Lambdas</p> <pre><code>@MyAnnotation(converter = { it.toString() })\n</code></pre> <p>A lambda generates a class at compilation. This generated class will be used as the value for this attribute.</p>"},{"location":"language-specification/source-file-structure/classes/","title":"Classes","text":"<p>You can define classes using the <code>class</code> keyword</p> <pre><code>class Foo {\n\n}\n</code></pre>"},{"location":"language-specification/source-file-structure/classes/#extendingimplementing-classesinterfaces","title":"Extending/Implementing classes/interfaces","text":"<p>The syntax is like Java's</p> <pre><code>class Foo extends Object implements List&lt;Integer&gt; {\n\n}\n</code></pre>"},{"location":"language-specification/source-file-structure/classes/#class-visibility","title":"Class visibility","text":"<p>You can specify your class's visibility before the <code>class</code> keyword</p> <pre><code>public class Foo {\n\n}\n</code></pre>"},{"location":"language-specification/source-file-structure/classes/#class-functions","title":"Class functions","text":"<p>See the functions section to see how to define functions</p>"},{"location":"language-specification/source-file-structure/classes/#class-fields","title":"Class fields","text":"<p>You can define class fields like you would in Java</p> <pre><code>class Foo {\n  private int a;\n  double b = 3\n  Object c;\n}\n</code></pre>"},{"location":"language-specification/source-file-structure/classes/#constructors","title":"Constructors","text":"<p>You can use the keyword <code>constructor</code> to define constructors. The definition is similar to a function</p> <pre><code>class Foo {\n  int bar\n  String zoo\n\n  constructor(int bar, String zoo) {\n    this.bar = bar\n    this.zoo = zoo\n  }\n}\n</code></pre> <p>Constructors where you just want to assign values to your fields are common use-cases. Marcel has a syntax allowing you to write such constructors with a less verbose code.</p> <pre><code>class Foo {\n  int bar\n  String zoo\n\n  constructor(this.bar, this.zoo)\n}\n</code></pre> <p>We didn't even specify a function block, but you can specify one if you want. The first statements of your class will be the field assignments (after the super() call of course).</p>"},{"location":"language-specification/source-file-structure/classes/#calling-constructors","title":"Calling constructors","text":"<p>You can call specific <code>super</code> and <code>this</code> constructors.</p> <pre><code>class A {\n  int foo\n  constructor(this.foo)\n}\n\nclass B extends A {\n  int bar\n  constructor(int foo, this.bar): super(foo) {\n    println(\"Yahoo\")  \n  }\n\n  constructor(this.bar): this(0, bar)\n\n}\n</code></pre>"},{"location":"language-specification/source-file-structure/enums/","title":"Enum classes","text":"<p>You can define enums using the <code>enum</code> keyword</p> <pre><code>enum Foo {\n  BAR, ZOO\n}\n</code></pre>"},{"location":"language-specification/source-file-structure/functions/","title":"Functions","text":"<p>Use the <code>fun</code> keyword to define functions</p> <pre><code>fun int sum(int a, int b) {\n  return a + b\n}\n\nprotected fun void foo() {\n  // do nothing\n}\n</code></pre> <p>As shown in the above example, a function define has the following structures 1. starts with the visibility which is optional and defaults to <code>public</code>.(you can also define static function with the <code>static</code> keyword) 2. the <code>fun</code> keyword 3. the return type 4. the function's name 5. the list of your function's parameters. The parameter's type first, and then the parameter's name.</p> <p>If your function only contains one statement/expression, you can specify it with the below syntax</p> <pre><code>fun int sum(int a, int b) -&gt; a + b\n\nprotected fun void foo() -&gt; println(\"Did nothing\")\n</code></pre>"},{"location":"language-specification/source-file-structure/functions/#function-visibility","title":"Function Visibility","text":"<p>You can specify your function's visibility before the <code>fun</code> keyword</p> <pre><code>private fun foo() {\n}\n</code></pre>"},{"location":"language-specification/source-file-structure/functions/#function-calls","title":"Function Calls","text":"<p>Function calls are no different from in any other language</p> <pre><code>int result = sum(1, 2)\n</code></pre>"},{"location":"language-specification/source-file-structure/functions/#cast-results","title":"Cast Results","text":"<p>Marcel has a diamond operator for function calls which is different from Java's. It casts the  result of the function to the specified type.</p> <pre><code>Foo otherResult = compute&lt;Foo&gt;()\n</code></pre> <p>This above example isn't really useful as Marcel automatically cast variable assignments when needed but this feature can be useful when chaining function calls</p> <pre><code>Optional opt = Optional.of(new Foo())\n// assuming computeObject() and result return Object in their declaration\nBar result = opt.get&lt;Foo&gt;().computeObject&lt;Bar&gt;()\n</code></pre> <p>But note that this is useless if the function/property already returns the specified type in their declaration.</p>"},{"location":"language-specification/source-file-structure/functions/#named-parameters-call","title":"Named Parameters Call","text":"<p>You can also call a function by specifying its parameters by name. When doing so, the order in which you specify them doesn't matter.</p> <p>Such calls can also start with positional arguments.</p> <p>Following on our <code>sum()</code> example:</p> <pre><code>int result = sum(b: 2, a: 1) // equivalent to sum(1, 2)\nint otherResult = sum(1, b: 0) // equivalent to sum(1, 0)\n</code></pre> <p>It works the same with constructors. Here are some examples below.</p> <pre><code>class B {\n  int i\n  int j\n\n  constructor(this.i, this.j)\n\n}\nclass C {\n  int a\n  int b\n}\n\nB b = new B(i: 1, j: 2) // will call new B(i, j)\nC c = new C(b: 2, a: 1) // will call new C(a, b)\n</code></pre> <pre><code>int result = sum(2, b: 1) // equivalent to sum(2, 1)\n\nint otherResult = sum(a: 2, 1) // ERROR, positional argument is not at the start \n</code></pre> <p>Note that you can only used named parameters call for functions of Marcel-compiled classes, because Java doesn't keep method parameter names available at runtime by default.</p>"},{"location":"language-specification/source-file-structure/functions/#parameter-default-value","title":"Parameter default value","text":"<p>Function parameters can have default values, which are used when you skip the corresponding argument. These can be useful especially with named parameters function calls. </p> <pre><code>fun int sum(int a = 0, int b = 8) {\nreturn a + b\n}\n\nsum(a: 2) // 2 + 8\nsum(b: 5) // 0 + 8\nsum(a: 2, b: 5) // 2 + 5\n</code></pre> <p>You can specify any expression from a static context (this means you can't call/use non static functions/fields from the class your method is defined).</p> <p>These default parameter values are kept after compilation so you can also benefit them from other Marcel libraries.</p>"},{"location":"language-specification/source-file-structure/functions/#optional-parenthesis","title":"Optional parenthesis","text":"<p>When calling a function with at least one parameter, you can omit the parenthesis.</p> <p>Here are some examples</p> <pre><code>int result = sum 1, 2\nprintln result\n\ndoSomethingWithAnIntAndALambda 1, { /* my lambda */ }\n</code></pre>"},{"location":"language-specification/source-file-structure/imports/","title":"Imports","text":""},{"location":"language-specification/source-file-structure/imports/#imports","title":"Imports","text":"<p>Marcel's imports are very similar to Java's.</p>"},{"location":"language-specification/source-file-structure/imports/#class-import","title":"Class import","text":"<p>Such imports are like Java's</p> <pre><code>import java.text.SimpleDateFormat\n</code></pre> <p>But Marcel adds the capability to import a class <code>as</code> a given name. All references to the given name will be replaced by the actual class imported when compiling</p> <pre><code>import java.text.SimpleDateFormat as SDF\n\nSDF sdf = someSdf()\n</code></pre>"},{"location":"language-specification/source-file-structure/imports/#wildcard-imports","title":"Wildcard imports","text":"<p>Again, just like Java</p> <pre><code>import java.text.*\n</code></pre>"},{"location":"language-specification/source-file-structure/imports/#static-imports","title":"Static imports","text":"<p>Yup, like in Java</p> <pre><code>import static org.junit.jupiter.api.Assertions.assertEquals\n</code></pre>"},{"location":"language-specification/source-file-structure/imports/#default-imports","title":"Default imports","text":"<p>Marcel import by default all the following packages - java.lang. - java.util. - java.io. - marcel.lang.</p>"},{"location":"language-specification/source-file-structure/script/","title":"Write Scripts","text":"<p>Scripts don't need a main() function. You can just start writing statements of your script directly, without wrapping them in a method. Script can be executed easily with MarCL.</p> <p></p> <p>You can also define functions in your scripts.</p> <p>E.g.</p> <pre><code>println(fibonacci(10))\n\n@cached\nfun int fibonacci(int n) -&gt; switch (n) {\n  0, 1 -&gt; n\n  else -&gt; fibonacci(n - 1) + fibonacci(n - 2)\n}\n</code></pre>"},{"location":"language-specification/source-file-structure/script/#local-variables","title":"Local Variables","text":"<p>To declare a local variable in a script, simply declare it as you would in a function's body.</p> <pre><code>int a = 2\nint b\n</code></pre>"},{"location":"language-specification/source-file-structure/script/#fields","title":"Fields","text":"<p>To declare a class field for your script, you must explicitly provide its visibility, otherwise it will be  considered as a local variable.</p> <p>E.g.</p> <pre><code>internal int myField1 = 2\nprotected myfield2\n</code></pre>"},{"location":"language-specification/source-file-structure/script/#global-variables","title":"Global variables","text":"<p>Global variables are similar to fields. They were created especially for Marshell, in which you can't declare fields.</p>"},{"location":"language-specification/source-file-structure/script/#classes","title":"Classes","text":"<p>You can also define classes in a script, but note that such classes will not be an inner class of your script. They will be  top-level classes.</p>"},{"location":"language-specification/source-file-structure/visibility/","title":"Visibility and Access","text":"<p>In marcel, there are 4 kinds of visibility.</p> <ul> <li><code>public</code> -&gt; which refers to Java's public visibility. Your class/method/field may be accessible from any package</li> <li><code>protected</code> -&gt; which refers to Java's protected visibility. Your class/method/field may only be accessible from other classes in the same package or inheriting your class</li> <li><code>internal</code> -&gt; which refers to Java's package-private visibility. Your class/method/field may only be accessible from classes in the same package</li> <li><code>private</code> -&gt; Your method may be accessible only from the class it was defined in</li> </ul> <p>The default visibility is <code>public</code> (meaning that when it isn't specified, the class/method/field will be considered as public)</p>"},{"location":"language-specification/source-file-structure/visibility/#access","title":"Access","text":"<p>Class/method/fields access should be specified in the below order.</p> <ol> <li>public/protected/internal/private (or nothing, which would default to public visibility)</li> <li>static (Optional. only if you want your member to be static)</li> <li>final (Optional. only if you want your member to be final)</li> </ol>"},{"location":"language-specification/types/","title":"Types","text":"<p>In this section we'll explore some common Marcel types.</p>"},{"location":"language-specification/types/#java-types","title":"Java Types","text":"<p>Marcel is a JVM language, therefore you can use any classes defined in the JDK.</p>"},{"location":"language-specification/types/#generic-types","title":"Generic Types","text":"<p>Marcel does not support generic types (except for collections of primitives which technically aren't generic as they are mapped to specific interfaces). </p> <p>You can use generic classes but cannot specify type parameters when using them. It's a conscious choice made to get rid of some complexity while developing the compiler and also because Java always casts at runtime anyway.</p>"},{"location":"language-specification/types/arrays/","title":"Arrays","text":"<p>Marcel supports Java arrays and has a syntax to specify array values.</p> <p>Create arrays with the square brackets.</p> <pre><code>int[] ints = [1, 2, 3, 4]\n</code></pre> <p>Note that you can also use this syntax to create collections.</p>"},{"location":"language-specification/types/collections-of-primitives/","title":"Collections of Primitives","text":"<p>Marcel allows to use collections with primitive elements. Such collections will not box all your primitives into their related Object class (e.g. store an int into an Integer). The elements will be stored in an array of primitives.</p> <p>Iterating over such collections will only use primitives, no (un)boxing will be done.</p> <p>Let's learn by example</p>"},{"location":"language-specification/types/collections-of-primitives/#lists","title":"Lists","text":"<pre><code>List&lt;int&gt; list = [1, 2, 3, 4]\n\nprintln(list[1])\n\nlist[1] = 1\nprintln(list[1])\n</code></pre> <p>Here, we're declaring a <code>List&lt;int&gt;</code>. This type isn't actually generic, it is in fact an IntList (you can see this class in the marcel stdlib), and the literal array will be converted into a IntArrayList (a int list that store elements in an int array).</p> <p>Here is the list of all list of primitives supported - List\\ -&gt; IntList - List\\ -&gt; LongList - List\\ -&gt; FloatList - List\\ -&gt; DoubleList - List\\ -&gt; CharacterList"},{"location":"language-specification/types/collections-of-primitives/#sets","title":"Sets","text":"<p>You can do the same with sets</p> <pre><code>Set&lt;int&gt; mySet = [1, 2, 3, 3] // will actually contain just 1, 2 and 3\n</code></pre> <p>Here is the list of all set of primitives supported - Set\\ -&gt; IntSet - Set\\ -&gt; LongSet - Set\\ -&gt; FloatSet - Set\\ -&gt; DoubleSet - Set\\ -&gt; CharacterSet"},{"location":"language-specification/types/collections/","title":"Collections","text":"<p>TODO</p>"},{"location":"language-specification/types/dynamic-objects/","title":"Dynamic Objects","text":"<p>Dynamic Objects are the one and only dynamic feature in Marcel. They allow you to manipulate any kind of objects using  dynamic properties and method calls.</p>"},{"location":"language-specification/types/dynamic-objects/#what-does-it-do","title":"What does it do","text":"<p>DynamicObject (or <code>dynobj</code>) is an interface that is handled specially by the Marcel compiler. All field access, method calls and operator uses on a DynamicObject  are resolved at runtime instead of compile-time.</p> <p>The DynamicObject wraps an actual (and non dynamic) object. Various types are handled in order to make them easy to manipulate through the  DynamicObject API. For example, you can manipulate maps like objects with properties.</p> <pre><code>dynobj dMap = [foo: 'bar', zoo: 'pew'] as dynobj\n\nprintln(dMap.foo)\ndMap.zoo = 8\n</code></pre> <p>Note that dynamic method calls won't be applicable for all methods of the actual object wrapped by the dynobj, this feature is limited. And if you attempt to call a method that isn't defined/handled, you will get an error at runtime.</p> <pre><code>dynobj o = 1\nprintln(o[1]) // will throw MissingMethodException at runtime, instead of a semantic error at compile time\n</code></pre> <p>The same behaviour applies for field access.</p>"},{"location":"language-specification/types/dynamic-objects/#register-fieldsmethods","title":"Register fields/methods","text":"<p>Dynamic Objects allow you to register method/fields to specific instances. Use the <code>registerMethod</code>/<code>registerField</code> methods for that.</p> <pre><code>dynobj o = 1\n\no.registerMethod(\"foo\", Integer.class) { Integer i -&gt; i * 2 + 1 }\nprintln(o.foo(1)) // 3\n\no.registerField(\"bar\", \"value\")\nprintln(o.bar) // value\no.bar = \"new value\"\nprintln(o.bar) // new value\n</code></pre>"},{"location":"language-specification/types/maps/","title":"Maps","text":"<p>Square brackets can also be used to define maps</p> <pre><code>Map map = [1.3: \"1\", 1.4: \"2\", \"myStringKey\": \"myStringValue\", \n           myLiteralKey: myRefValue, (myRefKey): myRefValue]\n</code></pre> <p>Note that <code>myLiteralKey</code> is actually a String key, it doesn't refer to a variable (like in Groovy). If you want to reference a variable as a key, put it between parenthesis, like it is done for <code>(myRefKey)</code>.</p>"},{"location":"language-specification/types/maps/#iterating-over-maps","title":"Iterating over maps","text":"<p>To iterate over maps you can use the below syntax</p> <pre><code>Map map = [(1): \"some\", (2): \"another\"]\nfor ((int key, String value) in map) {\n  println(\"$key -&gt; $value\")\n}\n</code></pre>"},{"location":"language-specification/types/objects/","title":"Objects","text":"<p>Any non-null value that is not a primitive is an Object.</p> <p>As specified before, Marcel is a JVM language, therefore you can use any classes defined in the JDK.</p> <p>You can also define classes in Marcel</p>"},{"location":"language-specification/types/primitives/","title":"Primitives","text":"<p>Marcel supports the following Java primitives</p> <ul> <li>void</li> <li>boolean (bool)</li> <li>byte</li> <li>short</li> <li>int</li> <li>long</li> <li>float</li> <li>double</li> <li>char</li> <li>byte</li> </ul>"},{"location":"language-specification/types/primitives/#literal-numbers","title":"Literal Numbers","text":"<p>Marcel supports almost all Java primitives. The number primitive literals are the same as in Java</p> <pre><code>// primitive types\nbyte  b = 1\nshort s = 2\nint   i = 3\nlong  l = 4l\nfloat f = 5f\ndouble d = 6d\n</code></pre>"},{"location":"language-specification/types/primitives/#binary-representation","title":"Binary representation","text":"<p>You can also create numbers using their binary representation with the <code>0b</code> prefix</p> <pre><code>int i = 0b10\nlong l = 0b11l\n</code></pre>"},{"location":"language-specification/types/primitives/#hexadecimal-representation","title":"Hexadecimal representation","text":"<p>You can also create numbers using their hexadecimal representation with the <code>0x</code> prefix</p> <pre><code>int i = 0x5\nlong l = 0x5l\n</code></pre>"},{"location":"language-specification/types/primitives/#boolean","title":"boolean","text":"<p>You can create booleans using the <code>true</code> or <code>false</code> keyword.</p> <pre><code>bool b = true\n</code></pre>"},{"location":"language-specification/types/primitives/#char","title":"char","text":"<p>Use the backtick (<code>`</code>) to create primitive characters. Only one character must be specified between the two backticks</p> <pre><code>char c = `A`\n</code></pre>"},{"location":"language-specification/types/primitives/#escaped-characters","title":"Escaped characters","text":"<p>Use backslash to escape 'special' characters within strings/characters. Here is the list of escaped characters</p> escaped character represented value \\b backspace \\n newline \\r carriage return \\t tabulation \\\\ backslash \\\\' single quotes (useful in simple strings) \\\\\" double quotes (useful in interpolated strings) \\` backtick (useful in character strings)"},{"location":"language-specification/types/ranges/","title":"Ranges","text":"<p>A Range represents the list of discrete items between some starting (or from) value and working towards some ending (or to) value. It may be reversed (e.g. from 10 to 1).</p> <p>Marcel provides <code>IntRange</code> and <code>LongRange</code></p> <pre><code>for (int i in 0..&lt;5) println(i)\n\nfor (long i in 10l..1l) println(i)\n\n</code></pre> <p>You can create int (and long) ranges</p> <pre><code>0..10 // 0 (inclusive) to 10 (inclusive)\n0&lt;..10 // 0 (exclusive) to 10 (inclusive)\n0..&lt;10 // 0 (inclusive) to 10 (exclusive)\n0&lt;..&lt;10 // 0 (exclusive) to 10 (exclusive)\n</code></pre> <p>Ranges also work in reverse order</p> <pre><code>10..0 // 10 (inclusive) to 0 (inclusive)\n10&gt;..0 // 10 (exclusive) to 0 (inclusive)\n10..&gt;0 // 10 (inclusive) to 0 (exclusive)\n10&gt;..&gt;0 // 10 (exclusive) to 0 (exclusive)\n</code></pre> <p>Ranges work with all kinds of int/long expressions</p> <pre><code>int start = computeStart()\nint end = computeEnd()\n\nfor (int i in start..(end - 1)) println(i)\n</code></pre>"},{"location":"language-specification/types/string/","title":"String","text":"<p>The Java String as you know it.  There are different ways to create strings in Marcel</p>"},{"location":"language-specification/types/string/#simple-strings","title":"Simple strings","text":"<p>You can use the single quote character (<code>'</code>) to create strings</p> <pre><code>'Hello world!'\n</code></pre>"},{"location":"language-specification/types/string/#interpolated-strings","title":"Interpolated strings","text":"<p>You can use the double quote character (<code>\"</code>) to create strings resolving variables</p> <pre><code>\"$firstName $lastName is $age years old\"\n</code></pre> <p>If you need to access a property, use the brackets</p> <pre><code>\"${person.firstName} ${person.lastName} is ${person.age} years old\"\n</code></pre>"},{"location":"language-specification/types/string/#pattern-strings","title":"Pattern strings","text":"<p>You can instantiate Patterns using backslash strings. These strings are reserved for pattern only.</p> <p>The backslash is not considered as an escape, except for the backlash character (which would be escaped as <code>\\/</code>).</p> <pre><code>r/some \\w+/\n</code></pre> <p>Note that such strings doesn't resolve variables. If you want to construct a Pattern while resolving Strings, you could just call the <code>Pattern.compile(String)</code> method with an interpolated string.</p> <p></p> <p>It is good practise to end such regexes with a semi-colon (<code>;</code>) character, to make it clear to the compiler that what follows is not a regex flag (we'll talk about that just after) but a 'real' identifier.</p> <p>E.g.</p> <pre><code>Pattern pattern = r/myPattern/; // without the semi-colon, Marcel would think that 'println' characters are regex flags\nprintln(pattern)\n</code></pre>"},{"location":"language-specification/types/string/#pattern-flags","title":"Pattern flags","text":"<p>You can also specify flags by adding a suffix at the end of your regex String.</p> <pre><code>Pattern pattern = r/myPattern/iu; // you can specify many flags at once\nprintln(pattern)\n</code></pre> <p>Here is the list of flags (you can see the doc of each flag in the Javadoc of the Pattern's class).</p> character Java PatternFlag d UNIX_LINES i CASE_INSENSITIVE x COMMENTS m MULTILINE l LITERAL s DOTALL u UNICODE_CASE c CANON_EQ U UNICODE_CHARACTER_CLASS"},{"location":"metaprogramming/","title":"Metaprogramming in Marcel","text":"<p>Marcel offers some metaprogramming features, allowing you to write code that generates code.</p> <p>Such code is generating while compiling it. As Marcel is a static language, it only supports compile-time metaprogramming and has no runtime metaprogramming features.</p>"},{"location":"metaprogramming/#compile-time-metaprogramming-with-syntax-tree-transformations","title":"Compile-time metaprogramming with Syntax Tree Transformations","text":"<p>Syntax Tree Transformations can modify the representation of your source code before converting it into Java bytecode.</p> <p>This process can alter the Concrete Syntax Tree (CST) and/or the Abstract Syntax Tree (AST) of your program.</p> <p>This concept is similar as Groovy's AST transformations, except that in Marcel you can also transform the CST, and the AST transformation occurs after the semantic analysis. </p> <p>This <code>SyntaxTreeTransformation</code> interface specifies the transformation of a CST/AST node and operates in 2 steps occurring in different phases of the compilation process (3 if you count the initialization).</p>"},{"location":"metaprogramming/#how-syntax-tree-transformations-operate","title":"How Syntax Tree Transformations operate","text":"<p>After the parsing of your code which outputs the Concrete Syntax Tree (CST), and before performing the semantic analysis which would generate the Abstract Syntax Tree (AST), all symbols (classes, methods, fields) are defined.</p> <p>Then occurs the first step of an Syntax Tree transformation: the symbol definition transformation. A Syntax Tree transformation can alter the definition of symbols  (e.g. make your class implement an interface, or add a field to a class, modify a method signature...). This step only affects the definition of the symbols. It tells the compiler (for example) that \"This class also implements the Foo interface\" or \"This class has a field bar of type int\", and the compiler will just have to trust it, especially when performing the semantic analysis.</p> <p>In this step you can also modify the Concrete Syntax Tree.</p> <p>After all the Syntax Tree transformations completed their first step, the semantic analysis is performed. </p> <p>Finally, comes the second step of Syntax Tree transformations: the AST transformation. This step can alter in many ways the AST, but it must alter it carefully as not all semantic checks are performed while doing so. </p> <p>The modifications made on the AST must also be coherent with the previous symbol definition transformations.  E.g. if we defined a new method in the first step, we must create and add a new valid method node with the same signature in the AST, in the second step.</p>"},{"location":"metaprogramming/meta-annotations/","title":"Meta-annotations (metaprogramming with annotations)","text":"<p>AST transformations can be specified on annotations. Doing so allows to perform specific transformations when annotating a given class, field, method and/or field.</p> <p>Marcel's standard library provides many annotations useful to avoid writing boilerplate code. Some of them are similar as the one you could find in Lombok.</p> <p>Meta-annotations from the Marcel's standard-library are all lowercase (even the first letter), this is how you can differentiate them from other (non-meta) annotations.</p>"},{"location":"metaprogramming/meta-annotations/#cached","title":"@cached","text":"<p>This annotation allows to cache results of a method in order to prevent having to compute multiple times the result for a same input. It will generate a cache and make the annotated method use this cache. The cache key is produced with the method parameter(s).</p> <p>If the value for the given input (method parameters) is in the cache, we just return it from the cache. If it isn't in it, we compute the value, put it in the cache and then return it.</p> <p>A perfect example is a recursive implementation of the fibonacci suite. With high numbers, we may compute multiple times the value for a same input, making the operation really long. That's where <code>@cached</code> comes to save the day. No value for a same input will be computed more than once, this will allow to save a lot of time.</p> <pre><code>println(fibonacci(10))\n\n@cached\nfun int fibonacci(int n) -&gt; switch (n) {\n  0, 1 -&gt; n\n  else -&gt; fibonacci(n - 1) + fibonacci(n - 2)\n}\n</code></pre> <p>This script would print <code>Foo(bar=myBar)</code>.</p> <p>Caching also work with functions having many parameters</p> <pre><code>println(funnynacci(10, 15))\n\n@cached\nfun int funnynacci(int n, int m) -&gt; switch (n) {\n  0, 1 -&gt; n + m\n  else -&gt; funnynacci(n - 1, m - 1) + funnynacci(n - 2, m - 1)\n}\n</code></pre>"},{"location":"metaprogramming/meta-annotations/#thread-safe-cache","title":"Thread-safe cache","text":"<p>By default, the cache is not thread safe and is backed by a HashMap.</p> <p>You can set the <code>threadSafe</code> flag to <code>true</code> if you want to make the implementation thread-safe. The cache will then be backed by a ConcurrentHashMap.</p> <pre><code>println(fibonacci(10))\n\n@cached(threadSafe=true)\nfun int fibonacci(int n) -&gt; switch (n) {\n  0, 1 -&gt; n\n  else -&gt; fibonacci(n - 1) + fibonacci(n - 2)\n}\n</code></pre>"},{"location":"metaprogramming/meta-annotations/#comparable","title":"@comparable","text":"<p>This makes your class implement Comparable interface. The comparison will be made based on your class's field, in the order in which they were defined.</p> <p>For example take a look at the below class</p> <pre><code>@comparable\nclass Foo {\n  int a\n  String b\n  double c\n}\n</code></pre> <p>When comparing 2 Foo instances, we'll start by comparing the fields <code>a</code>. If they are not the same (one is greater/lower than the other), we'll stop the comparison here as we already can determine which Foo instance is greater than the other. If both <code>a</code> fields hold the same value, we'll continue the comparison with <code>b</code>, and so on and so on...</p>"},{"location":"metaprogramming/meta-annotations/#include-getters","title":"Include getters","text":"<p>The getters are not included in the generated Comparison by default. To change this behaviour, you can use the flag <code>includeGetters=true</code>.</p>"},{"location":"metaprogramming/meta-annotations/#exclude-particular-fieldsmethods","title":"Exclude particular fields/methods","text":"<p>You can use the annotation <code>@comparable.Exclude</code> to exclude a particular field or getter.</p> <pre><code>@comparable(includeGetters=true)\nclass Foo {\n int i = 1\n\n @comparable.Exclude\n String b = \"srsr\"\n\n @comparable.Exclude\n fun String getFoo() -&gt; \"foo\"\n\n fun String getBar() -&gt; \"bar\"\n}\n</code></pre>"},{"location":"metaprogramming/meta-annotations/#data","title":"@data","text":"<p>This annotation is similar to Lombok's @Data annotation. It auto-generates the <code>equals()</code>, <code>hashCode()</code> and <code>toString()</code> method for your class, based on your class's members.</p> <p>The</p> <p>You can also make your class implement Comparable by providing the <code>comparable=true</code> flag</p> <pre><code>@data\nclass Foo {\n  int a = 2\n  String b = \"b\"\n}\n</code></pre>"},{"location":"metaprogramming/meta-annotations/#exclude-particular-fieldsmethods_1","title":"Exclude particular fields/methods","text":"<p>You can use the <code>@data.Exclude</code>, <code>@comparable.Exclude</code> or <code>@stringify.Exclude</code> annotations to exclude properties from the sring representation,</p> <p><code>@data.Exclude</code> will exclude the property from both the <code>toString()</code>, and the <code>equals()</code>,<code>hashCode()</code> methods. <code>@comparable.Exclude</code> will only exclude the property for the <code>equals()</code>,<code>hashCode()</code> methods. <code>@stringify.Exclude</code> will only exclude the property for the <code>toString()</code> method.</p> <pre><code>@data\nclass Foo {\n @data.Exclude\n int i = 1\n\n @comparable.Exclude\n String b = \"srsr\"\n\n @comparable.Exclude\n fun String getFoo() -&gt; \"foo\"\n\n fun String getBar() -&gt; \"bar\"\n}\n</code></pre>"},{"location":"metaprogramming/meta-annotations/#lazy","title":"@lazy","text":"<p>This annotation is used to make a field lazy. The value of the field will only be computed when it is referenced, and not before.</p>"},{"location":"metaprogramming/meta-annotations/#prerequisites","title":"Prerequisites","text":"<p>The annotated field must be of Object type (non-primitive) and must have an initial value specified.</p> <p>E.g.</p> <pre><code>@lazy\nInteger i = computeI()\n\nfun int computeI() {\n  initCount++\n  return 1\n}\n</code></pre>"},{"location":"metaprogramming/meta-annotations/#how-it-is-transformed","title":"How it is transformed","text":"<p>This meta-annotation will transform the code to make the annotated field lazy.</p> <p>Using the above example, the code would be transformed as such</p> <pre><code>private Integer _i = null\n\nfun getI() {\n  if (_i == null) {\n    _i = computeI()\n  }\n  return _i\n}\n\nfun int computeI() {\n  initCount++\n  return 1\n}\n</code></pre> <p>As Marcel allows to access getters as properties, you can access this variable using the <code>a</code> syntax (or <code>this.a</code>), as if you were referencing the original field. You'll notice that in the above script, the value of <code>i</code> will never be computed, as the variable <code>i</code> wasn't referenced anywhere outside.</p> <p>Now let's take a look at a full example.</p> <pre><code>@lazy\nInteger i = computeI()\n\nfor (int _ in 1..3) println(i)\n\nfun int computeI() {\n  initCount++\n  return 1\n}\n</code></pre> <p>The output of the above script would be</p> <pre><code>Computing...\n1\n1\n1\n</code></pre> <p>As the variable is lazy, the value of i will be computed at the first call of <code>println(i)</code>, and the other calls will just use the already computed value.</p>"},{"location":"metaprogramming/meta-annotations/#stringify","title":"@stringify","text":"<p>This annotation is similar to Lombok's @ToString annotation. It auto-generates a <code>toString()</code> method for your class, based on your class's members.</p> <p>The generated toString method will put all fields of the class with their values in the generated String.</p> <pre><code>@stringify\nclass Foo {\n String bar = \"myBar\"\n}\n\nprintln(new Foo())\n</code></pre> <p>This script would print <code>Foo(bar=myBar)</code>.</p>"},{"location":"metaprogramming/meta-annotations/#include-getters_1","title":"Include getters","text":"<p>The getters are not included in the generated String by default. To change this behaviour, you can use the flag <code>includeGetters=true</code>.</p> <pre><code>@stringify(includeGetters=true)\nclass Foo {\n String bar = \"myBar\"\n\n fun int getZoo() -&gt; 5 \n}\n\nprintln(new Foo())\n</code></pre> <p>This script would print <code>Foo(bar=myBar, zoo=5)</code>.</p>"},{"location":"metaprogramming/meta-annotations/#exclude-particular-fieldsmethods_2","title":"Exclude particular fields/methods","text":"<p>You can use the annotation <code>@stringify.Exclude</code> to exclude a particular field or getter.</p> <pre><code>@stringify(includeGetters=true)\nclass Foo {\n int i = 1\n\n @stringify.Exclude\n String b = \"srsr\"\n\n @stringify.Exclude\n fun String getFoo() -&gt; \"foo\"\n\n fun String getBar() -&gt; \"bar\"\n}\n</code></pre> <p>This script would print <code>A(i=1, bar=bar)</code>. </p>"},{"location":"tools/dumbbell/","title":"Dumbbell - Marcel's dependency manager","text":"<p>Dumbbell is a dependency manager for Marcel. It allows you to easily import dependencies in your scripts, without having to create a Maven/Gradle project.</p> <p>It was inspired strongly from Groovy's grapes</p> <p></p>"},{"location":"tools/dumbbell/#import-dependencies-in-a-script","title":"Import dependencies in a script","text":"<p>To import a dependency, use the <code>dumbbell</code> keyword.</p> <pre><code>dumbbell 'com.google.code.gson:gson:2.8.6'\nimport com.google.gson.Gson\n\nGson gson = new Gson()\n\nprintln(gson.toJson(['a': 'b']))\n</code></pre> <p>Dependencies are pulled from Maven central. The list of repository to pull from will be configurable (someday).</p> <p>Note that this feature only works when running scripts with MarCL.</p>"},{"location":"tools/dumbbell/#import-dependencies-in-marshell","title":"Import dependencies in Marshell","text":"<p>Dumbbell is also used in Marshell. Use the <code>:pull</code> command to pull  dependencies dynamically.</p>"},{"location":"tools/intelij-plugin/","title":"IntelIJ Plugin for Marcel","text":"<p>Here is the IntelIJ plugin to support Marcel on your IDE. This plugin has very limited features (it only does syntax highlighting...)</p> <p>Link here</p>"},{"location":"tools/marcel-for-android/","title":"Marcel for Android","text":"<p>Marcel for Android is the Marshell app made for Android, but with additional features. You can download it here.</p> <p>Note that it was designed for dark theme so this app is much more UI friendly in dark mode. An update will come soon(-ish) to better handle light mode.</p> <p>With this app you can - Run Marcel shells, as you would using Marshell - edit Marcel source codes - Schedule Shell Works, a concept allowing you to run Marcel scripts in the background, with the possibility to schedules the works and make them periodic.</p> <p>You can consult the privacy policy of this app here.</p>"},{"location":"tools/marcel-for-android/#initialization-scripts","title":"Initialization scripts","text":"<p>You can also use Marshell's initialization scripts to enhance your experience.</p>"},{"location":"tools/marcel-for-android/#send-system-notifications-from-marcel-script","title":"Send System Notifications from Marcel Script","text":"<p>Marcel for Android has integration with your Android system APIs. You can write code that sends a system notification to your Android device. This also applies to Shell Workouts, meaning that you can notify your device in your script executed in the background.</p>"},{"location":"tools/marcel-for-android/#send-notification","title":"Send Notification","text":"<p>Here is an example of code to notify.</p> <pre><code>AndroidSystem.notify('Hello World', 'This is a notification')\n</code></pre> <p></p>"},{"location":"tools/marcel-for-android/#send-sms-from-marcel-script","title":"Send SMS from Marcel Script","text":"<p>FEATURE NOT ACCESSIBLE FROM PLAYSTORE RELEASE: sending SMS is not a core functionality of my app, that's why, unfortunately, Google prevents me from enabling this feature on the published app in the PlayStore.</p> <p>Marcel for Android has integration with your Android system APIs. You can write code that sends SMS. This also applies to Shell Workouts, meaning that you can schedule for later a SMS.</p>"},{"location":"tools/marcel-for-android/#sms-permission","title":"SMS Permission","text":"<p>Before being able to send an SMS from a Marcel script, you must allow the app to do so. Go to the Settings screen, and then enable the 'Send SMS' permission, as shown in the below screenshot.</p>"},{"location":"tools/marcel-for-android/#send-sms","title":"Send SMS","text":"<p>Here is an example of code to send SMS.</p> <pre><code>AndroidSystem.sendSms('+331234567890', 'Hello World')\n</code></pre> <p>Marcel cannot access your contacts, so you'll have to put the international phone numbers, in E.164 format (the format starting with <code>+</code>).</p>"},{"location":"tools/marcel-for-android/#list-sms","title":"List SMS","text":"<p>You can list sent SMS to track their status.</p> <pre><code>AndroidSystem.listSms()\n</code></pre>"},{"location":"tools/marcel-for-android/#screenshots","title":"Screenshots","text":""},{"location":"tools/marcel-for-android/#shell-workouts","title":"Shell Workouts","text":"<p>Shell Workouts are scripts that you can execute in the background. They can perform heavy I/O operations while you do other things on your phone.</p> <p>They were implemented using Android's WorkoutManager.</p> <p>Thanks to these APIs, you can schedule Shell Workouts to run at a specific time, and/or make them periodic so that they are run every x hours.</p> <p>TODO add screenshot and examples</p>"},{"location":"tools/marcel-for-android/#privacy-policy","title":"Privacy Policy","text":"<p>Marcel for Android is an open-source application. You can consult its full source code on GitHub.</p> <p>This application does not collect any analytics or personal data from its users.</p>"},{"location":"tools/marcl/","title":"Marcl","text":"<p>MarCL (MARcel Command Line tool) is useful to compile/execute marcel source files/scripts.</p> <p>Let's explore all the commands it provides</p>"},{"location":"tools/marcl/#execute","title":"Execute","text":"<p>This is the default command, meaning that if you don't specify a command, it will use this one.</p> <pre><code>Usage: marcl execute [OPTIONS] FILE [SCRIPT_ARGUMENTS]...\n\n  Execute a marcel script\n\nOptions:\n  -c, --keep-class         keep compiled class files after execution\n  -j, --keep-jar           keep compiled jar file after execution\n  -p, --print-stack-trace  print stack trace on compilation error\n  -h, --help               Show this message and exit\n</code></pre>"},{"location":"tools/marcl/#examples","title":"Examples","text":"<pre><code>marcl execute script.mcl\n</code></pre> <pre><code>marcl -c script.mcl\n</code></pre> <pre><code>marcl execute -cj script.mcl myScriptArg1 myScriptArg2\n</code></pre>"},{"location":"tools/marcl/#compile","title":"Compile","text":"<pre><code>Usage: marcl compile [OPTIONS] FILE\n\n  Compiles a Marcel class to a .class file and/or .jar file\n\nOptions:\n  -c, --class              Compile to class\n  -j, --jar                Compile to jar\n  -p, --print-stack-trace  print stack trace on compilation error\n  -h, --help               Show this message and exit\n\n</code></pre>"},{"location":"tools/marcl/#examples_1","title":"Examples","text":"<pre><code>marcl compile script.mcl\n</code></pre> <pre><code>marcl compile -cj script.mcl\n</code></pre>"},{"location":"tools/marshell/","title":"Marshell","text":"<p>Marshell is a shell that can be used to run marcel instructions, on the fly. It is a Read Eval Print Loop tool.</p> <p>It is the equivalent of groovysh for Marcel.</p> <p>This shell supports syntax highlighting and also highlights defined functions/variables.</p>"},{"location":"tools/marshell/#global-variables","title":"Global variables","text":"<p>In marshell, you can't have class fields, but you can use global variables. To declare a global variable, just assign to a variable a value, without specifying its type</p> <pre><code>a = 1 // this will create a global variable a\n</code></pre> <p>We didn't declare the variable <code>a</code>. If we were in a regular class/source file this wouldn't compile, but in Marshell this is possible.</p> <p>The type of the global variable is determined by the value provided, and it can't change type. Meaning that after having defining one, you can't assign to it a value that is of an incompatible type of the one you used when you first assigned it a value.</p> <pre><code>a = 1\n\ndoSomething(a)\n\na = \"2\" // Semantic Error: Expected expression of type int but gave String\n</code></pre> <p>To explicitly specify the type of the global variable, use the <code>as</code> keyword.</p> <pre><code>a = [1, 2] as Set&lt;int&gt;\n</code></pre>"},{"location":"tools/marshell/#how-global-variables-works","title":"How global variables works","text":"<p>Global variables are variables that are stored in the script's Binding. The means you could also retrieve them/set them using methods like <code>Script.getVariable(name)</code>/<code>Script.setVariable(name, value)</code></p>"},{"location":"tools/marshell/#define-functions","title":"Define functions","text":"<p>Define functions as you would in a Marcel script</p>"},{"location":"tools/marshell/#define-classes","title":"Define classes","text":"<p>Define classes as you would in a Marcel script. All defined classes are top-level classes (they are not inner class as they would be in a Marcel script).</p>"},{"location":"tools/marshell/#run-commands","title":"Run commands","text":"<p>Marshell has some specific commands make your experience even better.</p> <p>Use the <code>:help</code> command to see all the commands (marshell-specific instructions) you can run</p>"},{"location":"tools/marshell/#import-dependencies","title":"Import dependencies","text":"<p>You can import dependencies on the fly with the <code>:pull</code> command</p> <pre><code>marshell:000&gt; :pull com.google.code.gson:gson:2.10.1\nmarshell:000&gt; :import com.google.gson.Gson\nmarshell:000&gt; gson = new Gson()\n</code></pre>"},{"location":"tools/marshell/#initialisation-script","title":"Initialisation script","text":"<p>If you want to always load some data everytime you run marshell, you can create a script in <code>$MARCEL_HOME/marshell/init.mcl</code>.</p> <p>In this script you can't use commands. If you want to import a dependency/dumbbell, just do it like you would in a normal marcel script (<code>import ...</code> or <code>dumbbell '...'</code>)</p>"},{"location":"tools/marshell/#marshell-initialization-scripts","title":"Marshell initialization scripts","text":"<p>Here are some useful initialization scripts that you can use for your shells. These scripts provide useful methods and utilities to enhance your marshell experience, given a context.</p>"},{"location":"tools/marshell/#file-explorer-initializer","title":"File explorer initializer","text":"<p>With the below script, transform Marshell into a file explorer, with shell-like methods such as <code>cd</code>, <code>ls</code> and a variable <code>pwd</code> to get the current directory.</p> <pre><code>pwd = System.getProperty(\"user.home\") ? new File(System.getProperty(\"user.home\"))\n    // for Marshell android compatibility\n    : getVariable&lt;File&gt;('ROOT_DIR')\nif (pwd == null) {\n  println(\"WARNING: Couldn't initialise properly pwd\")\n}\n_hint = pwd\n\n\nfun File cd(String path) {\n  File f = pwd.child(path)\n  if (!f.exists()) throw new IllegalArgumentException(\"Directory $f doesn't exists\")\n  if (!f.isDirectory()) throw new IllegalArgumentException(\"File $f isn't a directory\")\n  pwd = f\n  _hint = pwd\n  return f\n}\n\n\nfun File file(String path) -&gt; pwd.child(path)\n\nfun void ls() {\n  File[] files = pwd.listFiles()\n  if (files != null) {\n    for (File f in files) println(\"- $f\")\n  }\n}\n</code></pre>"},{"location":"tools/maven-plugin/","title":"Maven Plugin for Marcel","text":"<p>Here is the official plugin to compile marcel source files under a Maven project. The Marcel source files should be placed under the <code>src/main/marcel</code> directory.</p> <p>Link here</p>"}]}